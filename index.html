<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valorium X — The Ethical Blockchain</title>
    <meta name="description" content="A security-first, post-quantum Layer 1 blockchain built for the long term. No hype, just verifiable work.">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://valoriumx-demo.netlify.app">
    <meta property="og:title" content="Valorium X — The Ethical Blockchain">
    <meta property="og:description" content="Post-quantum security. Solar-powered mining. Community-governed. A Layer 1 blockchain built for the future.">
    <meta property="og:image" content="https://valoriumx-demo.netlify.app/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Valorium X">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Valorium X — The Ethical Blockchain">
    <meta name="twitter:description" content="Post-quantum security. Solar-powered mining. Community-governed. Built for the future.">
    <meta name="twitter:image" content="https://valoriumx-demo.netlify.app/og-image.png">
    <link rel="stylesheet" href="fonts.css">
    <link rel="stylesheet" href="style.css?v=1771390558">
    <script src="assets/js/rive-webgl2.js" defer></script>
    <script src="assets/js/gsap.min.js" defer></script>
    <script src="assets/js/lenis.min.js"></script>
</head>
<body class="pre-boot">
<script>
// --- LENIS SMOOTH SCROLL (global) ---
var _lenis = new Lenis({
    duration: 1.2,
    easing: function(t) { return Math.min(1, 1.001 - Math.pow(2, -10 * t)); },
    touchMultiplier: 2,
    smoothWheel: true
});
function _lenisRAF(time) {
    _lenis.raf(time);
    requestAnimationFrame(_lenisRAF);
}
requestAnimationFrame(_lenisRAF);
window._lenis = _lenis;
</script>
<!-- CUSTOM CURSOR -->
<div class="cursor" id="cursor"></div>
<div class="cursor-ring" id="cursorRing"></div>


<!-- Background Music -->
<audio id="bgMusic" preload="metadata" loop>
    <source src="bg-music.mp3" type="audio/mpeg">
</audio>

<!-- SVG GLOW FILTER -->
<svg class="svg-engine" aria-hidden="true" style="position:absolute;width:0;height:0;pointer-events:none">
    <defs>
        <filter id="glow-v7-cyan" color-interpolation-filters="sRGB" x="-50%" y="-200%" width="200%" height="500%">
            <feGaussianBlur in="SourceGraphic" stdDeviation="4" result="blur4" />
            <feGaussianBlur in="SourceGraphic" stdDeviation="19" result="blur19" />
            <feGaussianBlur in="SourceGraphic" stdDeviation="9" result="blur9" />
            <feGaussianBlur in="SourceGraphic" stdDeviation="30" result="blur30" />
            <feColorMatrix in="blur4" result="color-0-blur" type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0" />
            <feOffset in="color-0-blur" result="layer-0-offsetted" dx="0" dy="0" />
            <feColorMatrix in="blur19" result="color-1-blur" type="matrix" values="0 0 0 0 0 0 0.95 0 0 0 0 0 1 0 0 0 0 0 1 0" />
            <feOffset in="color-1-blur" result="layer-1-offsetted" dx="0" dy="2" />
            <feColorMatrix in="blur9" result="color-2-blur" type="matrix" values="0 0 0 0 0 0 0.5 0 0 0 0 0 1 0 0 0 0 0 0.7 0" />
            <feOffset in="color-2-blur" result="layer-2-offsetted" dx="0" dy="2" />
            <feColorMatrix in="blur30" result="color-3-blur" type="matrix" values="0 0 0 0 0 0 0.2 0 0 0 0 0 0.8 0 0 0 0 0 0.6 0" />
            <feOffset in="color-3-blur" result="layer-3-offsetted" dx="0" dy="2" />
            <feMerge>
                <feMergeNode in="layer-3-offsetted" />
                <feMergeNode in="layer-2-offsetted" />
                <feMergeNode in="layer-1-offsetted" />
                <feMergeNode in="layer-0-offsetted" />
                <feMergeNode in="SourceGraphic" />
            </feMerge>
        </filter>
    </defs>
</svg>

<!-- PARTICLE LOADER -->
<canvas id="fx-canvas"></canvas>
<div class="loader-overlay" id="uiOverlay"></div>
<div class="flash-overlay" id="flashOverlay"></div>
<div class="logo-container" id="logoContainer" tabindex="0" role="button" aria-label="Initialize Valorium X">
    <div class="style-layer layer-new"></div>
    <div class="style-layer layer-holographic"></div>
    <div class="style-layer layer-cybernetic"></div>
    <div class="style-layer layer-depressed"></div>
    <div class="tech-ring ring-1"></div>
    <div class="tech-ring ring-2"></div>
    <div class="tech-ring ring-3"></div>
    <div class="tech-ring ring-4"></div>
    <span class="loader-logo-x">X</span>
    <div class="hint">Hold to Initialize</div>
</div>


<!-- NAV -->
<nav class="nav" id="nav">
    <div class="nav-inner">
        <a href="#" class="nav-logo">
            <span class="logo-v">V</span>ALORIUM <span class="logo-x">X</span>
        </a>
        <div class="nav-links" id="navLinks">
            <a href="#warpZone">About</a>
            <a href="#how">DNA</a>
            <a href="#ecosystem">Ecosystem</a>
            <a href="#miners">Miners</a>
            <a href="#roadmap">Roadmap</a>
            <a href="#journey">Journey</a>
        </div>
        <div class="nav-actions">
            <a href="#journey" class="nav-cta">Get Started</a>
        </div>
        <button class="nav-toggle" id="navToggle" aria-label="Menu">
            <span></span><span></span><span></span>
        </button>
    </div>
    <!-- Audio toggle -->
    <button class="audio-toggle" id="audioToggle" aria-label="Toggle music">
        <svg class="audio-icon audio-icon-off" id="audioIconOff" viewBox="0 0 24 24" fill="none" width="20" height="20">
            <path d="M11 5L6 9H2v6h4l5 4V5z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <line x1="23" y1="9" x2="17" y2="15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <line x1="17" y1="9" x2="23" y2="15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
        <svg class="audio-icon audio-icon-on" id="audioIconOn" viewBox="0 0 24 24" fill="none" width="20" height="20" style="display:none">
            <path d="M11 5L6 9H2v6h4l5 4V5z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M15.54 8.46a5 5 0 010 7.07" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M19.07 4.93a10 10 0 010 14.14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
    </button>
</nav>

<!-- HERO — WebGL Sun Shader -->
<header class="hero-header" id="heroHeader">
    <canvas id="glcanvas"></canvas>
    <img class="hero-logo" src="valorium-logo.webp" alt="Valorium X" />
    <div class="token-glow-overlay" id="tokenGlowOverlay"></div>
    <canvas id="lightningCanvas" class="lightning-overlay"></canvas>
    <div class="hero-brand" id="heroBrand">
        <span class="brand-v">V</span><span class="brand-text">ALORIUM</span> <span class="brand-x">X</span>
    </div>
    <div class="scroll-indicator" id="scrollIndicator">
        <div class="scroll-line"></div>
        <div class="scroll-chevron"></div>
    </div>
</header>

<script>
// --- CUSTOM CURSOR ---
var cursor = document.getElementById('cursor');
var ring = document.getElementById('cursorRing');
var cx = 0, cy = 0, rx = 0, ry = 0;
var isHover = false;

if (window.matchMedia('(pointer: fine)').matches) {
    document.addEventListener('mousemove', function(e) {
        cx = e.clientX; cy = e.clientY;
        cursor.style.transform = 'translate(' + cx + 'px,' + cy + 'px)';
    }, { passive: true });

    function ringLoop() {
        rx += (cx - rx) * 0.15;
        ry += (cy - ry) * 0.15;
        ring.style.transform = 'translate(' + rx + 'px,' + ry + 'px) scale(' + (isHover ? 2.5 : 1) + ')';
        requestAnimationFrame(ringLoop);
    }
    ringLoop();

    document.querySelectorAll('[data-hover]').forEach(function(el) {
        el.addEventListener('mouseenter', function() { isHover = true; });
        el.addEventListener('mouseleave', function() { isHover = false; });
    });
} else {
    cursor.style.display = 'none';
    ring.style.display = 'none';
}
</script>

<!-- ═══ WARP TUNNEL ZONE ═══ -->
<section class="warp-zone" id="warpZone">
    <div class="warp-stage" id="warpStage">
        <!-- Overlays -->
        <div class="wz-scanlines"></div>
        <div class="wz-vignette"></div>
        <div class="wz-noise"></div>
        <!-- HUD -->
        <div class="wz-hud" id="warpHud">
            <div class="wz-hud-top">
                <span>SYS.READY</span>
                <div class="wz-hud-line"></div>
                <span>FPS: <strong id="warpFps">60</strong></span>
            </div>
            <div class="wz-hud-side">
                SCROLL VELOCITY // <strong id="warpVel">0.00</strong>
            </div>
            <div class="wz-hud-bottom">
                <span>COORD: <strong id="warpCoord">000.000</strong></span>
                <div class="wz-hud-line"></div>
                <span>VRX NETWORK [ACTIVE]</span>
            </div>
        </div>
        <!-- 3D Scene -->
        <div class="wz-viewport" id="warpViewport">
            <div class="wz-world" id="warpWorld"></div>
        </div>
    </div>
</section>

<script>
// === WARP TUNNEL ENGINE (single-pass, smooth scroll) ===
(function() {
    var warpZone = document.getElementById('warpZone');
    var warpStage = document.getElementById('warpStage');
    var warpWorld = document.getElementById('warpWorld');
    var warpViewport = document.getElementById('warpViewport');
    if (!warpZone || !warpWorld) return;

    // --- CONFIGURATION ---
    var CONFIG = {
        itemCount: 20,
        starCount: 150,
        zGap: 800,
        camSpeed: 8
    };
    var totalDepth = CONFIG.itemCount * CONFIG.zGap;

    // Set section height dynamically: exact scroll needed + 1 viewport
    var scrollNeeded = (totalDepth + 300) / CONFIG.camSpeed;
    warpZone.style.height = (scrollNeeded + window.innerHeight) + 'px';

    // ValoriumX card content
    var CARD_DATA = [
        { title: 'POST-QUANTUM', subtitle: 'CRYSTALS-Dilithium', id: 'PQ-001' },
        { title: 'DUAL-HELIX', subtitle: 'Double-chain security', id: 'DH-002' },
        { title: 'SOLAR MINING', subtitle: '25W per miner', id: 'SM-003' },
        { title: 'LAYER-1', subtitle: 'Built from scratch', id: 'L1-004' },
        { title: 'FAIR VOTE', subtitle: '1 person = 1 vote', id: 'FV-005' },
        { title: 'NEURAL NODES', subtitle: 'AI-powered validation', id: 'NN-006' },
        { title: 'OPEN SOURCE', subtitle: '100% public code', id: 'OS-007' },
        { title: 'REAL COMPANY', subtitle: 'Registered in Canada', id: 'RC-008' },
        { title: 'VRX TOKEN', subtitle: 'Earned, never sold', id: 'VT-009' },
        { title: 'RUST CORE', subtitle: 'Memory-safe blockchain', id: 'RS-010' },
        { title: 'GREEN MINING', subtitle: 'Solar-powered nodes', id: 'GM-011' },
        { title: 'QUANTUM PROOF', subtitle: 'Lattice cryptography', id: 'QP-012' },
        { title: 'MESH NETWORK', subtitle: 'Decentralized peers', id: 'MN-013' },
        { title: 'ZERO PREMINE', subtitle: 'No insider allocation', id: 'ZP-014' },
        { title: 'CIP CONSENSUS', subtitle: 'Interlocking proof', id: 'CC-015' }
    ];

    var TEXTS = ['VALORIUM', 'QUANTUM', 'SECURE', 'DECENTRALIZED', 'FUTURE',
                 'SOLAR', 'ETHICAL', 'LAYER-1', 'HELIX', 'PROOF'];

    // --- STATE ---
    var smoothScroll = 0;   // Lerped scroll value (what we render)
    var targetScroll = 0;   // Raw scroll target
    var velocity = 0;       // Smoothed velocity for effects
    var mouseX = 0, mouseY = 0;
    var active = false;

    var items = [];

    // --- INIT ITEMS ---
    var cardIndex = 0;
    for (var i = 0; i < CONFIG.itemCount; i++) {
        var el = document.createElement('div');
        el.className = 'wz-item';
        var isHeading = (i % 4 === 0);

        if (isHeading) {
            var txt = document.createElement('div');
            txt.className = 'wz-big-text';
            txt.innerText = TEXTS[i % TEXTS.length];
            el.appendChild(txt);
            items.push({
                el: el, type: 'text',
                x: 0, y: 0, rot: 0,
                baseZ: -i * CONFIG.zGap
            });
        } else {
            var data = CARD_DATA[cardIndex % CARD_DATA.length];
            cardIndex++;
            var card = document.createElement('div');
            card.className = 'wz-card';
            card.innerHTML =
                '<div class="wz-card-header">' +
                    '<span class="wz-card-id">' + data.id + '</span>' +
                    '<div style="width:10px;height:10px;background:var(--accent);"></div>' +
                '</div>' +
                '<h2>' + data.title + '</h2>' +
                '<div class="wz-card-footer">' +
                    '<span>' + data.subtitle + '</span>' +
                    '<span>VRX-CHAIN</span>' +
                '</div>' +
                '<div style="position:absolute;bottom:2rem;right:2rem;font-size:4rem;opacity:0.1;font-weight:900;">' +
                    String(i).padStart(2, '0') +
                '</div>';
            el.appendChild(card);

            var angle = (i / CONFIG.itemCount) * Math.PI * 6;
            var x = Math.cos(angle) * (window.innerWidth * 0.3);
            var y = Math.sin(angle) * (window.innerHeight * 0.3);
            var rot = (Math.random() - 0.5) * 30;

            items.push({
                el: el, type: 'card',
                x: x, y: y, rot: rot,
                baseZ: -i * CONFIG.zGap
            });
        }
        warpWorld.appendChild(el);
    }

    // Stars spread across one-pass depth
    for (var s = 0; s < CONFIG.starCount; s++) {
        var starEl = document.createElement('div');
        starEl.className = 'wz-star';
        warpWorld.appendChild(starEl);
        items.push({
            el: starEl, type: 'star',
            x: (Math.random() - 0.5) * 3000,
            y: (Math.random() - 0.5) * 3000,
            baseZ: -Math.random() * totalDepth
        });
    }

    // --- MOUSE TILT ---
    window.addEventListener('mousemove', function(e) {
        mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
        mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
    }, { passive: true });

    // --- SECTION-SCOPED SCROLL READING (cached layout) ---
    var _cachedTop = 0, _cachedHeight = 0;
    function _cacheLayout() {
        var el = warpZone; _cachedTop = 0;
        while (el) { _cachedTop += el.offsetTop; el = el.offsetParent; }
        _cachedHeight = warpZone.offsetHeight - window.innerHeight;
    }
    _cacheLayout();
    window.addEventListener('resize', _cacheLayout);

    function getRawProgress() {
        var progress = (window.scrollY || window.pageYOffset) - _cachedTop;
        return Math.max(0, Math.min(progress, _cachedHeight));
    }

    // --- INTERSECTION OBSERVER ---
    var warpObserver = new IntersectionObserver(function(entries) {
        entries.forEach(function(e) {
            if (e.isIntersecting) {
                // Reset warp state if returning from panels
                if (warpZone._panelTriggered) {
                    warpZone._panelTriggered = false;
                    warpStage.style.opacity = 1;
                    // Snap both to current position — no rewind lag
                    var raw = getRawProgress();
                    smoothScroll = raw;
                    targetScroll = raw;
                }
                if (!active) {
                    active = true;
                    requestAnimationFrame(warpRAF);
                }
            } else {
                active = false;
            }
        });
    }, { rootMargin: '100px 0px', threshold: 0 });
    warpObserver.observe(warpStage);

    // --- HUD ---
    var fpsEl = document.getElementById('warpFps');
    var velEl = document.getElementById('warpVel');
    var coordEl = document.getElementById('warpCoord');

    // --- RENDER LOOP ---
    var lastTime = 0;
    var frameCount = 0;
    var LERP = 0.08; // Smooth scroll lerp factor (lower = smoother/heavier)

    function warpRAF(time) {
        if (!active) return;
        requestAnimationFrame(warpRAF);

        // FPS
        var delta = time - lastTime;
        lastTime = time;
        frameCount++;
        if (fpsEl && frameCount % 10 === 0) {
            fpsEl.innerText = Math.round(1000 / delta);
        }

        // Read raw scroll and lerp toward it
        targetScroll = getRawProgress();
        var prevSmooth = smoothScroll;
        smoothScroll += (targetScroll - smoothScroll) * LERP;

        // Smooth velocity from lerped scroll delta
        var rawVel = smoothScroll - prevSmooth;
        velocity += (rawVel - velocity) * 0.15;

        // HUD
        if (velEl) velEl.innerText = Math.abs(velocity).toFixed(2);
        if (coordEl) coordEl.innerText = Math.round(smoothScroll);

        // Camera tilt from mouse + velocity
        var tiltX = mouseY * 5 - velocity * 0.5;
        var tiltY = mouseX * 5;
        warpWorld.style.transform =
            'rotateX(' + tiltX + 'deg) rotateY(' + tiltY + 'deg)';

        // Dynamic perspective (warp on velocity)
        var baseFov = 1000;
        var fov = baseFov - Math.min(Math.abs(velocity) * 10, 600);
        warpViewport.style.perspective = fov + 'px';

        // Camera Z from SMOOTHED scroll
        var cameraZ = smoothScroll * CONFIG.camSpeed;

        // Update items — linear, no wrap
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var vizZ = item.baseZ + cameraZ;

            // Opacity
            var alpha = 1;
            if (vizZ < -3000) alpha = 0;
            else if (vizZ < -2000) alpha = (vizZ + 3000) / 1000;
            if (vizZ > 100 && item.type !== 'star') alpha = 1 - ((vizZ - 100) / 400);
            if (vizZ > 500) alpha = 0;
            if (alpha < 0) alpha = 0;
            item.el.style.opacity = alpha;

            if (alpha > 0) {
                var trans = 'translate3d(' + item.x + 'px,' + item.y + 'px,' + vizZ + 'px)';

                if (item.type === 'star') {
                    var stretch = Math.max(1, Math.min(1 + Math.abs(velocity) * 0.1, 10));
                    trans += ' scale3d(1,1,' + stretch + ')';
                } else if (item.type === 'text') {
                    trans += ' rotateZ(' + item.rot + 'deg)';
                    if (Math.abs(velocity) > 1) {
                        var offset = velocity * 2;
                        item.el.style.textShadow = offset + 'px 0 #8B5CF6, ' + (-offset) + 'px 0 #40d8ff';
                    } else {
                        item.el.style.textShadow = 'none';
                    }
                } else {
                    var t = time * 0.001;
                    var floatY = Math.sin(t + item.x) * 10;
                    trans += ' rotateZ(' + item.rot + 'deg) rotateY(' + floatY + 'deg)';
                }

                item.el.style.transform = trans;
            }
        }

        // --- SEAMLESS PANEL TRANSITION ---
        // As camera passes the last items, fade in first panel directly
        var maxItemZ = CONFIG.itemCount * CONFIG.zGap;
        // Progress: 0 at last item, 1 when 1500 Z-units past it
        var endProgress = (cameraZ - maxItemZ) / 300;
        endProgress = Math.max(0, Math.min(1, endProgress));

        if (endProgress > 0) {
            // Fade out warp overlays + HUD
            warpStage.style.opacity = 1 - endProgress;

            // When fully past, trigger panel lock
            if (endProgress >= 1 && !warpZone._panelTriggered) {
                warpZone._panelTriggered = true;
                // Keep render loop alive so scroll-back works immediately
                if (window._showFirstPanel) {
                    window._showFirstPanel();
                }
            }
        } else {
            warpStage.style.opacity = 1;
        }
    }
})();
</script>


<div id="panelContainer" class="panel-container">
<!-- THREE PROBLEMS -->
<section class="problems" id="problems" data-panel data-neon="cyan">
    <div class="problems-pin">
        <div class="problems-header">
            <span class="section-tag">The Big Picture</span>
            <h2 class="section-title">Three Problems<br>Nobody Has Solved</h2>
        </div>
        <div class="problems-track" id="problemsTrack">
            <article class="problem-card">
                <div class="problem-img">
                    <img src="quantum-reactor.webp" alt="Quantum Security" draggable="false">
                    <div class="problem-badge">01</div>
                </div>
                <div class="problem-body">
                    <span class="problem-tag">Post-Quantum Security</span>
                    <h3 class="problem-title">Quantum Computers<br>Will Break Bitcoin</h3>
                    <p class="problem-desc">Quantum computers crack RSA & ECC — the cryptography protecting every blockchain today. Timeline: 5-10 years. Valorium X uses lattice-based cryptography, immune from day one.</p>
                    <div class="problem-stats">
                        <div class="stat"><span class="stat-val">5-10</span><span class="stat-label">years until quantum threat</span></div>
                        <div class="stat"><span class="stat-val">0</span><span class="stat-label">migration needed</span></div>
                    </div>
                </div>
            </article>
            <article class="problem-card">
                <div class="problem-img">
                    <img src="energy-wind.webp" alt="Energy Efficiency" draggable="false">
                    <div class="problem-badge">02</div>
                </div>
                <div class="problem-body">
                    <span class="problem-tag">Energy Efficiency</span>
                    <h3 class="problem-title">Mining Should Not<br>Cost a Fortune</h3>
                    <p class="problem-desc">Bitcoin mining: 1,500W per machine. VRX mining: 25W — less than a light bulb. One $100 solar panel powers it 24/7. Zero electricity cost, pure accumulation.</p>
                    <div class="problem-stats">
                        <div class="stat"><span class="stat-val">25W</span><span class="stat-label">per miner</span></div>
                        <div class="stat"><span class="stat-val">60x</span><span class="stat-label">less than Bitcoin</span></div>
                    </div>
                </div>
            </article>
            <article class="problem-card">
                <div class="problem-img">
                    <img src="governance-suits.webp" alt="Fair Governance" draggable="false">
                    <div class="problem-badge">03</div>
                </div>
                <div class="problem-body">
                    <span class="problem-tag">Fair Governance</span>
                    <h3 class="problem-title">No More Billionaire<br>Takeovers</h3>
                    <p class="problem-desc">Bitcoin: rich buy more hash power. Ethereum: rich stake more, control more. Valorium X: 1 miner = 1 vote, always. A registered Canadian company with real accountability.</p>
                    <div class="problem-stats">
                        <div class="stat"><span class="stat-val">1:1</span><span class="stat-label">person to vote ratio</span></div>
                        <div class="stat"><span class="stat-val">CA</span><span class="stat-label">registered company</span></div>
                    </div>
                </div>
            </article>
        </div>
    </div>
</section>

<!-- DNA ARCHITECTURE -->
<section class="dna-section" id="how" data-panel data-neon="blue">
    <div class="dna-layout">
        <div class="dna-col-left" data-anim="fade-right">
            <span class="section-tag">How It Works</span>
            <h2 class="dna-heading">Built Like<br><span class="title-accent">DNA Itself</span></h2>
            <p class="dna-desc">Your DNA uses two intertwined strands that constantly check each other for errors &mdash; that is how life stays alive. Valorium X works the same way. Two chains watching each other, 24/7.</p>
            <div class="dna-callout">
                <span class="dna-callout-dot"></span>
                <strong>Dual-Helix Security</strong>
            </div>
            <p class="dna-callout-text">Nature perfected this design over billions of years. We just applied it to money.</p>
        </div>
        <div class="dna-col-center" data-anim="scale-in" data-delay="1">
            <div class="dna-container">
                <div class="helix-visual">
                    <div class="dna">
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                        <div class="link"><div></div><div></div></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="dna-col-right">
            <div class="dna-step" data-anim="fade-left" data-delay="1">
                <h3 class="dna-step-title">Your Money Chain</h3>
                <p class="dna-step-desc">Every transaction gets recorded in an unbreakable sequence &mdash; like a receipt book where every page is glued to the next.</p>
            </div>
            <div class="dna-step" data-anim="fade-left" data-delay="2">
                <h3 class="dna-step-title">The Security Guard</h3>
                <p class="dna-step-desc">A second independent chain watches the first one. A hacker would need to break both simultaneously &mdash; practically impossible.</p>
            </div>
            <div class="dna-step" data-anim="fade-left" data-delay="3">
                <h3 class="dna-step-title">Locked Like DNA</h3>
                <p class="dna-step-desc">The two chains are physically interlocked. You cannot change one without snapping the other. No other blockchain has this.</p>
            </div>
            <div class="dna-step" data-anim="fade-left" data-delay="4">
                <h3 class="dna-step-title">Real Work Mining</h3>
                <p class="dna-step-desc">Valorium X miners do useful computation that strengthens the network. You accumulate tokens AND contribute something real.</p>
            </div>
        </div>
    </div>
</section>

<!-- RIVE AI ANIMATION -->
<section class="rive-section" id="autonomy-deep" data-panel data-neon="cyan">
    <div class="rive-reveal-glow"></div>
    <div class="rive-reveal-wrap">
        <canvas id="riveAiCanvas"></canvas>
    </div>
</section>

<!-- QUANTUM-PROOF -->
<section class="quantum" id="quantum" data-panel data-neon="purple">
    <div class="container">
        <div class="quantum-grid">
            <div class="quantum-visual" data-anim="fade-right">
                <div class="lattice" id="lattice"></div>
            </div>
            <div class="quantum-content" data-anim="fade-left">
                <span class="section-tag">Future-Proof Security</span>
                <h2 class="section-title">Quantum-Proof<br>From Day One</h2>
                <p class="section-sub">Most blockchains will break when quantum computers arrive. ValoriumX was designed from scratch with post-quantum algorithms — the same ones governments use to protect classified data.</p>
                <ul class="quantum-list">
                    <li>
                        <div class="q-icon">&#10003;</div>
                        <div><strong>CRYSTALS-Dilithium Signatures</strong><br><span>Mathematically immune to quantum attacks</span></div>
                    </li>
                    <li>
                        <div class="q-icon">&#10003;</div>
                        <div><strong>No Migration Needed</strong><br><span>Built in from genesis block — not bolted on later</span></div>
                    </li>
                    <li>
                        <div class="q-icon">&#10003;</div>
                        <div><strong>Your Money Stays Safe</strong><br><span>Even when quantum computers become mainstream</span></div>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</section>

<!-- TRUST & TRANSPARENCY -->
<section class="trust" id="trust" data-panel data-neon="green">
    <div class="container">
        <span class="section-tag">Trust & Transparency</span>
        <h2 class="section-title">Real Company. Real People.</h2>
        <p class="section-sub">ValoriumX isn’t anonymous founders hiding behind a Discord handle. It’s a registered Canadian company with named leadership, public code, and zero tokens sold to insiders.</p>
        <div class="trust-grid">
            <div class="trust-card" data-anim="fade-up" data-delay="0" data-hover>
                <div class="trust-icon">&#127464;&#127462;</div>
                <h3>Registered in Canada</h3>
                <p>ValoriumX Inc. is a legally incorporated company — not an offshore shell or anonymous DAO.</p>
            </div>
            <div class="trust-card" data-anim="fade-up" data-delay="1" data-hover>
                <div class="trust-icon">&lt;/&gt;</div>
                <h3>100% Open Source</h3>
                <p>Every line of code is public on GitHub. No hidden backdoors, no secret tokenomics.</p>
            </div>
            <div class="trust-card" data-anim="fade-up" data-delay="2" data-hover>
                <div class="trust-icon">&#9675;</div>
                <h3>No Token Sale</h3>
                <p>Zero pre-mine. Zero VC allocation. Every VRX token is earned through mining — not bought.</p>
            </div>
            <div class="trust-card" data-anim="fade-up" data-delay="3" data-hover>
                <div class="trust-icon">&#9878;</div>
                <h3>1 Person = 1 Vote</h3>
                <p>No whale can buy control. Every participant has an equal voice in the network’s future.</p>
            </div>
        </div>
    </div>
</section>

<!-- ECOSYSTEM -->
<section class="ecosystem" id="ecosystem" data-panel data-neon="pink">
    <div class="container">
        <span class="section-tag">Ecosystem</span>
        <h2 class="section-title">Not Just a Coin.<br>An Entire World.</h2>
        <p class="section-sub">Most crypto projects give you a token and say ‘good luck.’ Valorium X is building a complete ecosystem — everything you need, all under one roof.</p>
        <div class="eco-grid">
            <div class="eco-card eco-card--large" data-anim="fade-up" data-delay="0" data-hover>
                <span class="eco-icon">&#128179;</span>
                <h3>Wallet</h3>
                <p>Your money, your control. A quantum-proof wallet as easy to use as a banking app but impossible to hack — even by future supercomputers.</p>
            </div>
            <div class="eco-card" data-anim="fade-up" data-delay="1" data-hover>
                <span class="eco-icon">&#128722;</span>
                <h3>Marketplace</h3>
                <p>Buy, sell, and trade directly. No middleman. The savings go back to you.</p>
            </div>
            <div class="eco-card" data-anim="fade-up" data-delay="2" data-hover>
                <span class="eco-icon">&#129504;</span>
                <h3>Neural Nodes</h3>
                <p>AI-powered network nodes that make the blockchain smarter over time.</p>
            </div>
            <div class="eco-card" data-anim="fade-up" data-delay="3" data-hover>
                <span class="eco-icon">&#9878;</span>
                <h3>Validators</h3>
                <p>Help verify transactions and accumulate tokens. If you have a computer, you can participate.</p>
            </div>
            <div class="eco-card" data-anim="fade-up" data-delay="4" data-hover>
                <span class="eco-icon">&#9889;</span>
                <h3>Miners</h3>
                <p>Real physical devices. Plug them in, they start accumulating. 25 watts — your bill barely moves.</p>
            </div>
            <div class="eco-card" data-anim="fade-up" data-delay="5" data-hover>
                <span class="eco-icon">&#127891;</span>
                <h3>Academy</h3>
                <p>Never touched crypto? The Academy teaches everything from zero. Built for real humans.</p>
            </div>
        </div>
    </div>
</section>

<!-- MINERS / HARDWARE -->
<section class="miners" id="miners" data-panel data-neon="orange">
    <div class="container">
        <span class="section-tag">Hardware</span>
        <h2 class="section-title">Your Personal Mining Rig</h2>
        <p class="section-sub">Remember when Bitcoin was new and you could mine it on your laptop? That window closed years ago. With Valorium X, that window is open right now.</p>
        <div class="miners-grid">
            <div class="miner-card" data-anim="fade-up" data-delay="0" data-hover>
                <div class="miner-img-wrap">
                    <img src="miner-vrx.webp" alt="VRX Miner Lite" draggable="false">
                </div>
                <div class="miner-badge">Residential</div>
                <h3>VRX Miner Lite</h3>
                <p class="miner-tagline">Less power than a light bulb</p>
                <div class="miner-specs">
                    <div><span>Power</span><strong>25W</strong></div>
                    <div><span>Noise</span><strong>Silent</strong></div>
                    <div><span>Solar</span><strong>Yes</strong></div>
                    <div><span>Setup</span><strong>Plug & Play</strong></div>
                </div>
                <p class="miner-note">Plug it in and forget it. Pennies per month — or zero with a solar panel.</p>
            </div>
            <div class="miner-card miner-card--featured" data-anim="fade-up" data-delay="1" data-hover>
                <div class="miner-img-wrap">
                    <img src="miner-vrx.webp" alt="VRX Miner Pro" draggable="false">
                </div>
                <div class="miner-badge">Semi-Pro</div>
                <h3>VRX Miner Pro</h3>
                <p class="miner-tagline">Maximum output, minimal footprint</p>
                <div class="miner-specs">
                    <div><span>Power</span><strong>67W</strong></div>
                    <div><span>Noise</span><strong>Low</strong></div>
                    <div><span>Solar</span><strong>Yes</strong></div>
                    <div><span>Setup</span><strong>Plug & Play</strong></div>
                </div>
                <p class="miner-note">Stack a few with solar and you have a mini mining farm on pure sunlight. Zero cost, pure profit.</p>
            </div>
        </div>
        <div class="solar-callout" data-anim="fade-up">
            <div class="solar-icon">&#9728;</div>
            <div>
                <h3>The Solar Mining Revolution</h3>
                <p>A single $100 solar panel produces enough energy to power a VRX miner 24/7 with energy to spare. A one-time purchase — and you mine crypto for free, forever.</p>
            </div>
        </div>
    </div>
</section>

<!-- ROADMAP -->
<section class="roadmap" id="roadmap" data-panel data-neon="cyan">
    <div class="container">
        <span class="section-tag">Roadmap</span>
        <h2 class="section-title">Where This Is Going</h2>
        <p class="section-sub">Building methodically — no shortcuts, no empty promises. Every phase unlocks real value.</p>
    </div>
    <div class="roadmap-track-wrap">
        <div class="roadmap-track" id="roadmapTrack">
            <div class="roadmap-phase roadmap-phase--active" data-anim="fade-up">
                <div class="phase-status">In Progress</div>
                <h3>Phase 1 — Foundation</h3>
                <p>Building the Foundation</p>
                <ul>
                    <li>Core blockchain architecture in Rust</li>
                    <li>New consensus mechanism (CIP)</li>
                    <li>Double-helix ledger design</li>
                    <li>Mining hardware in production</li>
                    <li>Early community forming</li>
                </ul>
            </div>
            <div class="roadmap-phase" data-anim="fade-up" data-delay="1">
                <div class="phase-status">Upcoming</div>
                <h3>Phase 2 — Infrastructure</h3>
                <p>The Network Goes Live</p>
                <ul>
                    <li>Testnet launch</li>
                    <li>Mining software release</li>
                    <li>Wallet beta</li>
                    <li>Independent security audits</li>
                    <li>Validator onboarding</li>
                </ul>
            </div>
            <div class="roadmap-phase" data-anim="fade-up" data-delay="2">
                <div class="phase-status">Planned</div>
                <h3>Phase 3 — Expansion</h3>
                <p>The Floodgates Open</p>
                <ul>
                    <li>Mainnet launch</li>
                    <li>Marketplace opens</li>
                    <li>Neural Nodes go live</li>
                    <li>Academy launches</li>
                    <li>Exchange listings</li>
                </ul>
            </div>
            <div class="roadmap-phase" data-anim="fade-up" data-delay="3">
                <div class="phase-status">Future</div>
                <h3>Phase 4 — Maturity</h3>
                <p>World Stage</p>
                <ul>
                    <li>Cross-chain bridges</li>
                    <li>Enterprise partnerships</li>
                    <li>Full DAO governance</li>
                    <li>Smart contracts</li>
                    <li>Global expansion</li>
                </ul>
            </div>
        </div>
    </div>
</section>

<!-- GOVERNANCE -->
<section class="governance" id="governance" data-panel data-neon="purple">
    <div class="container">
        <span class="section-tag">Governance</span>
        <h2 class="section-title">Crypto The Way<br>It Should Be</h2>
        <p class="section-sub">Remember why people got excited about crypto? Freedom from centralized control. Transparency. Fairness. Most projects lost that vision. Valorium X brings it back.</p>
        <div class="gov-blocks">
            <div class="gov-block" data-anim="fade-up">
                <h3>One Person, One Vote</h3>
                <p>A billionaire and a student have the exact same voting power. Period. No amount of money can buy more influence. The most democratic blockchain ever designed.</p>
            </div>
            <div class="gov-block gov-block--right" data-anim="fade-up" data-delay="1">
                <h3>No Surprise Changes</h3>
                <p>Every update goes through public peer review first. No one — not even the founders — can sneak in changes. Total transparency.</p>
            </div>
            <div class="gov-block" data-anim="fade-up" data-delay="2">
                <h3>Real Company, Real Accountability</h3>
                <p>Valorium X Technologies Inc. is a registered Canadian company with a real address, real people, and real legal accountability.</p>
            </div>
        </div>
    </div>
</section>

<!-- DEVELOPERS -->
<section class="developers" id="developers" data-panel data-neon="green">
    <div class="container">
        <span class="section-tag">For Developers</span>
        <h2 class="section-title">Under the Hood</h2>
        <p class="section-sub">For researchers, auditors, and developers who want the technical details.</p>
        <div class="dev-accordion">
            <div class="dev-panel" data-hover>
                <button class="dev-header" aria-expanded="false">
                    <span>Architecture & Protocol Layers</span>
                    <span class="dev-toggle">+</span>
                </button>
                <div class="dev-content">
                    <ul>
                        <li><strong>Double-Helix Ledger:</strong> Two intertwined chains (Transaction + Validation) with cryptographic interlocking via CIP</li>
                        <li><strong>Quadrit Model:</strong> Novel data structure inspired by DNA quadruplex formations for efficient block encoding</li>
                        <li><strong>Genetic HD Paths:</strong> Hierarchical deterministic key derivation inspired by biological inheritance patterns</li>
                        <li><strong>Entangled Parcel Model (UTXO-DNA):</strong> Transaction structure combining UTXO efficiency with lineage tracking</li>
                        <li><strong>G-Quadruplex Buffer:</strong> Cryptographic buffering layer for enhanced security during consensus</li>
                    </ul>
                    <a href="https://github.com/ValoriumX/ValoriumX/wiki/Architecture-%26-Protocol-Layers" class="dev-link" target="_blank">Full documentation on GitHub Wiki &rarr;</a>
                </div>
            </div>
            <div class="dev-panel" data-hover>
                <button class="dev-header" aria-expanded="false">
                    <span>Consensus: CIP + VIC</span>
                    <span class="dev-toggle">+</span>
                </button>
                <div class="dev-content">
                    <ul>
                        <li><strong>CIP (Cryptographic Interlocking Proof):</strong> Novel consensus where validation and transaction chains cross-verify</li>
                        <li><strong>VIC (Valorium-Incentivized Consensus):</strong> Incentivizes useful computation rather than proof-of-wasted-energy</li>
                        <li><strong>Proof of Useful Work:</strong> Mining contributes real processing value to the network</li>
                        <li><strong>Spiking-Cortex Nodes:</strong> AI-assisted node architecture for intelligent network orchestration</li>
                    </ul>
                    <a href="https://github.com/ValoriumX/ValoriumX/wiki" class="dev-link" target="_blank">Consensus documentation &rarr;</a>
                </div>
            </div>
            <div class="dev-panel" data-hover>
                <button class="dev-header" aria-expanded="false">
                    <span>Post-Quantum Cryptography</span>
                    <span class="dev-toggle">+</span>
                </button>
                <div class="dev-content">
                    <ul>
                        <li>Designed from the ground up to resist quantum computing attacks</li>
                        <li>Uses lattice-based and hash-based cryptographic primitives</li>
                        <li>No dependency on RSA or elliptic curve cryptography for core security</li>
                        <li>Future-proof key management through genetic HD paths</li>
                    </ul>
                    <a href="https://github.com/ValoriumX/ValoriumX/wiki" class="dev-link" target="_blank">Security documentation &rarr;</a>
                </div>
            </div>
            <div class="dev-panel" data-hover>
                <button class="dev-header" aria-expanded="false">
                    <span>Built with Rust</span>
                    <span class="dev-toggle">+</span>
                </button>
                <div class="dev-content">
                    <ul>
                        <li>Core blockchain written in Rust for memory safety and performance</li>
                        <li>Zero-cost abstractions for high-throughput transaction processing</li>
                        <li>Same language powering Solana, Polkadot, and other serious L1 chains</li>
                        <li>Prevents entire classes of bugs (buffer overflows, null pointers, data races)</li>
                    </ul>
                    <a href="https://github.com/ValoriumX" class="dev-link" target="_blank">GitHub Repository &rarr;</a>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- COMMUNITY CTA -->
<section class="community" id="community" data-panel data-neon="blue">
    <canvas class="community-bg" id="communityBg"></canvas>
    <div class="container community-inner">
        <h2 class="community-title" data-anim="fade-up">The Early Ones<br>Win Big</h2>
        <p class="community-sub" data-anim="fade-up" data-delay="1">Every major crypto had a moment when early believers got in before the rest of the world noticed. For Valorium X, that moment is right now.</p>
        <a href="#" class="btn-primary btn-primary--large" data-anim="fade-up" data-delay="2">Get In Now</a>
    </div>
</section>

<!-- FOOTER -->
<footer class="footer" data-panel data-neon="gold">
    <div class="container">
        <div class="footer-grid">
            <div class="footer-brand">
                <div class="footer-logo">VALORIUM <span>X</span></div>
                <p>A security-first, post-quantum Layer 1 blockchain built for the long term.</p>
                <address>
                    Valorium X Technologies Inc.<br>
                    324 rue des Forges, local 201<br>
                    Trois-Rivi&egrave;res (QC), G9A 2G8<br>
                    Canada
                </address>
            </div>
            <div class="footer-col">
                <h4>Quick Links</h4>
                <a href="#warpZone">About</a>
                <a href="#how">How It Works</a>
                <a href="#ecosystem">Ecosystem</a>
                <a href="#miners">Miners</a>
                <a href="#roadmap">Roadmap</a>
            </div>
            <div class="footer-col">
                <h4>Resources</h4>
                <a href="https://github.com/ValoriumX/ValoriumX/wiki" target="_blank">Developer Docs</a>
                <a href="https://github.com/ValoriumX/ValoriumX/wiki" target="_blank">GitHub Wiki</a>
                <a href="#">Whitepaper</a>
                <a href="#">Academy</a>
            </div>
            <div class="footer-col">
                <h4>Contact</h4>
                <a href="mailto:info@valoriumx.org">info@valoriumx.org</a>
                <a href="mailto:security@valoriumx.org">security@valoriumx.org</a>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2026 Valorium X Technologies Inc. All rights reserved.</p>
            <p class="footer-disclaimer">This website is for informational purposes only. VRX is not a financial instrument and should not be considered an investment. Always do your own research.</p>
        </div>
    </div>
</footer>
</div>

<section class="flow-section" id="journey">

    <!-- Constellation background dots -->
    <canvas class="flow-constellation" id="flowConstellation"></canvas>

    <!-- Elbow connector SVG -->
    <svg class="flow-elbow-svg" id="flowElbowSvg" fill="none" xmlns="http://www.w3.org/2000/svg"></svg>


    <!-- HEADER -->
    <div class="flow-header" data-anim="blur-in">
        <span class="section-label">The Basics</span>
        <h2 class="section-title">We Made Mining Accessible to <span class="gradient-text">Everyone</span></h2>
    </div>

    <!-- ROW 1: Left text + Right "Unbox" terminal card -->
    <div class="flow-row flow-row-1">
        <!-- Handwritten annotation -->
        <div class="flow-annotation fa-1" data-anim="fade-up" data-delay="2">
            <span class="fa-text">step 1: plug it in</span>
            <svg class="fa-arrow fa-arrow-down-left" viewBox="0 0 60 50" fill="none"><path d="M52 5 C48 18, 35 30, 18 38" stroke="white" stroke-width="2.2" stroke-linecap="round" fill="none"/><path d="M24 34 L17 39 L23 43" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>
        </div>
        <div class="flow-blurb flow-blurb-left" data-anim="fade-right">
            <h3 class="flow-blurb-title">Zero Setup. <span class="flow-highlight-cyan">Instant Mining.</span></h3>
            <p class="flow-blurb-sub">One plug, that's it. No jargon, no PhD required.</p>
            <ul class="flow-checklist-v2">
                <li><span class="fcv2-icon"></span><strong>Plug into any wall outlet</strong></li>
                <li><span class="fcv2-icon"></span><strong>Connect to your WiFi</strong></li>
                <li><span class="fcv2-icon"></span><strong>Zero technical setup</strong></li>
            </ul>
        </div>
        <div class="flow-node flow-node-terminal" data-anim="fade-left" data-delay="1" id="fn1">
            <div class="fn-titlebar">
                <span class="fn-dot fn-dot-r"></span>
                <span class="fn-dot fn-dot-y"></span>
                <span class="fn-dot fn-dot-g"></span>
                <span class="fn-titlebar-text">vrx-miner &mdash; setup</span>
            </div>
            <div class="fn-body">
                <div class="fn-line"><span class="fn-prompt">$</span> plug in VRX Miner Lite</div>
                <div class="fn-line fn-line-ok"><span class="fn-check">&#10003;</span> Power: 25W &mdash; less than a light bulb</div>
                <div class="fn-line fn-line-ok"><span class="fn-check">&#10003;</span> WiFi connected</div>
                <div class="fn-line fn-line-ok"><span class="fn-check">&#10003;</span> Network discovered: 14,203 peers</div>
                <div class="fn-line fn-cursor"><span class="fn-prompt">$</span> mining started <span class="fn-blink">_</span></div>
            </div>
        </div>
    </div>

    <!-- FLOW LABEL -->
    <div class="flow-path-label" data-anim="fade-up">
        <span id="fpl1">Miner connects to decentralized mesh</span>
    </div>

    <!-- ROW 2: Left "Network" dashboard card + Right text -->
    <div class="flow-row flow-row-2">
        <!-- Handwritten annotation -->
        <div class="flow-annotation fa-2" data-anim="fade-up" data-delay="2">
            <span class="fa-text">step 2: it joins the network</span>
            <svg class="fa-arrow fa-arrow-down-right" viewBox="0 0 60 50" fill="none"><path d="M8 5 C12 18, 25 30, 42 38" stroke="white" stroke-width="2.2" stroke-linecap="round" fill="none"/><path d="M36 34 L43 39 L37 43" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>
        </div>
        <div class="flow-node flow-node-dashboard" data-anim="fade-right" data-delay="1" id="fn2">
            <div class="fn-titlebar fn-titlebar-dark">
                <span class="fn-badge">LIVE</span>
                <span class="fn-titlebar-text">Valorium Network</span>
            </div>
            <div class="fn-body fn-body-grid">
                <div class="fn-metric">
                    <span class="fn-metric-val fn-metric-cyan">14,203</span>
                    <span class="fn-metric-label">Active Miners</span>
                </div>
                <div class="fn-metric">
                    <span class="fn-metric-val fn-metric-gold">2 Chains</span>
                    <span class="fn-metric-label">Dual-Helix</span>
                </div>
                <div class="fn-metric">
                    <span class="fn-metric-val fn-metric-cyan">~0.4s</span>
                    <span class="fn-metric-label">Block Time</span>
                </div>
                <div class="fn-metric">
                    <span class="fn-metric-val fn-metric-gold">99.97%</span>
                    <span class="fn-metric-label">Uptime</span>
                </div>
            </div>
        </div>
        <div class="flow-blurb flow-blurb-right" data-anim="fade-left">
            <h3 class="flow-blurb-title">Two Chains. <span class="flow-highlight-cyan">Unbreakable.</span></h3>
            <p class="flow-blurb-sub">Dual-Helix security &mdash; like DNA strands cross-checking for errors.</p>
            <ul class="flow-checklist-v2">
                <li><span class="fcv2-icon"></span><strong>Two independent chains watch each other 24/7</strong></li>
                <li><span class="fcv2-icon"></span><strong>Both must be broken simultaneously to attack</strong></li>
                <li><span class="fcv2-icon"></span><strong>Practically impossible to compromise</strong></li>
            </ul>
        </div>
    </div>

    <!-- FLOW LABEL -->
    <div class="flow-path-label" data-anim="fade-up">
        <span id="fpl2">Real optical computation begins</span>
    </div>

    <!-- ROW 3: Big statement + Processing card -->
    <div class="flow-row flow-row-3">
        <!-- Handwritten annotation -->
        <div class="flow-annotation fa-3" data-anim="fade-up" data-delay="2">
            <span class="fa-text">step 3: real work happens here</span>
            <svg class="fa-arrow fa-arrow-down-left" viewBox="0 0 60 50" fill="none"><path d="M52 5 C48 18, 35 30, 18 38" stroke="white" stroke-width="2.2" stroke-linecap="round" fill="none"/><path d="M24 34 L17 39 L23 43" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>
        </div>
        <div class="flow-blurb flow-blurb-left" data-anim="fade-right">
            <h3 class="flow-blurb-title">Useful Work, not <span class="flow-strike">Puzzle-Solving</span></h3>
            <p class="flow-blurb-sub">Unlike Bitcoin's wasted energy, your miner does real optical computation.</p>
            <ul class="flow-checklist-v2">
                <li><span class="fcv2-icon"></span><strong>Processes real data that actually matters</strong></li>
                <li><span class="fcv2-icon"></span><strong>25W power draw &mdash; solar compatible</strong></li>
                <li><span class="fcv2-icon"></span><strong>Strengthens the network with every block</strong></li>
            </ul>
        </div>
        <div class="flow-node flow-node-process" data-anim="fade-left" data-delay="1" id="fn3">
            <div class="fn-titlebar">
                <span class="fn-dot fn-dot-r"></span>
                <span class="fn-dot fn-dot-y"></span>
                <span class="fn-dot fn-dot-g"></span>
                <span class="fn-titlebar-text">optical-processor</span>
            </div>
            <div class="fn-body">
                <div class="fn-line"><span class="fn-prompt">&gt;</span> Processing block #4,821,093</div>
                <div class="fn-line fn-line-dim"><span class="fn-prompt">&gt;</span> Optical matrix: 128-bit validation</div>
                <div class="fn-line fn-line-dim"><span class="fn-prompt">&gt;</span> Energy: 25W (solar compatible)</div>
                <div class="fn-progress">
                    <div class="fn-progress-bar"></div>
                </div>
                <div class="fn-line fn-line-ok"><span class="fn-check">&#10003;</span> Block validated &mdash; accumulated: 3.2 $VQXAI</div>
            </div>
        </div>
    </div>

    <!-- FLOW LABEL -->
    <div class="flow-path-label flow-path-label-gold" data-anim="fade-up">
        <span id="fpl3">Tokens accumulate automatically</span>
    </div>

    <!-- ROW 4: Wallet card + Final statement -->
    <div class="flow-row flow-row-4">
        <!-- Handwritten annotation -->
        <div class="flow-annotation fa-4" data-anim="fade-up" data-delay="2">
            <span class="fa-text">step 4: tokens accumulate</span>
            <svg class="fa-arrow fa-arrow-down-right" viewBox="0 0 60 50" fill="none"><path d="M8 5 C12 18, 25 30, 42 38" stroke="white" stroke-width="2.2" stroke-linecap="round" fill="none"/><path d="M36 34 L43 39 L37 43" stroke="white" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>
        </div>
        <div class="flow-node flow-node-wallet" data-anim="fade-right" data-delay="1" id="fn4">
            <div class="fn-wallet-header">
                <div class="fn-wallet-icon">
                    <svg viewBox="0 0 32 32" fill="none"><circle cx="16" cy="16" r="14" stroke="#F59E0B" stroke-width="1.5"/><text x="16" y="20" text-anchor="middle" fill="#F59E0B" font-family="Space Grotesk" font-size="10" font-weight="700">V</text></svg>
                </div>
                <div>
                    <div class="fn-wallet-title">$VQXAI Wallet</div>
                    <div class="fn-wallet-addr">0x7f2a...e91c</div>
                </div>
            </div>
            <div class="fn-wallet-balance">
                <span class="fn-wallet-amount">1,247.83</span>
                <span class="fn-wallet-ticker">$VQXAI</span>
            </div>
            <div class="fn-wallet-row">
                <span>Today</span>
                <span class="fn-wallet-gain">+12.4 $VQXAI</span>
            </div>
            <div class="fn-wallet-row">
                <span>This month</span>
                <span class="fn-wallet-gain">+384.2 $VQXAI</span>
            </div>
        </div>
        <div class="flow-blurb flow-blurb-right flow-blurb-final" data-anim="fade-left">
            <h3 class="flow-blurb-title">Accumulate while you sleep.</h3>
            <ul class="flow-checklist flow-checklist-gold">
                <li><span class="fc-dot fc-dot-gold"></span>No staking complexity</li>
                <li><span class="fc-dot fc-dot-gold"></span>No gas wars</li>
                <li><span class="fc-dot fc-dot-gold"></span>No middlemen</li>
                <li><span class="fc-dot fc-dot-gold"></span>Community-governed &mdash; you vote on the future</li>
            </ul>
            <a href="#miners" class="flow-cta-btn">See the Miners &rarr;</a>
        </div>
    </div>

</section>


<script>
// --- PARTICLE LOADER ---
document.body.style.overflow = 'hidden';
(function() {
    var canvas = document.getElementById('fx-canvas');
    var ctx = canvas.getContext('2d', { alpha: true });
    var logoBtn = document.getElementById('logoContainer');
    var uiOverlay = document.getElementById('uiOverlay');
    var flashOverlay = document.getElementById('flashOverlay');
    var layerHolo = document.querySelector('.layer-holographic');
    var layerCyber = document.querySelector('.layer-cybernetic');
    var rings = document.querySelectorAll('.tech-ring');
    var width, height, cx, cy, dpr = 1;
    var ringRotation = [0, 0, 0, 0];

    function resize() {
        dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        cx = width / 2;
        cy = height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    var isHolding = false, holdStart = 0, sequenceActive = false, systemOnline = false;
    var manualPhysics = false, suctionMode = false, suctionStrength = 0;
    var warpFactor = 0.5, targetWarpFactor = 0.5, gravityActive = false;
    var STARS_COUNT = 800;
    var TAU = Math.PI * 2;
    var stars = [], debris = [], shockwaves = [], lightning = [];

    function Star() { this.reset(); }
    Star.prototype.reset = function() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.z = Math.random() * width;
        this.size = Math.random() * 1.5;
        this.px = 0; this.py = 0;
        this.alpha = 1;
        this.isExploding = false;
        this.vx = 0; this.vy = 0;
        this.wobblePhase = Math.random() * TAU;
        this.twinkleSpeed = 0.05 + Math.random() * 0.1;
        this.twinkleVal = Math.random() * TAU;
        this.color = Math.random() > 0.8 ? "200, 255, 255" : "255, 255, 255";
    };
    Star.prototype.explode = function() {
        this.isExploding = true;
        var angle = Math.random() * TAU;
        var speed = 15 + 30 * Math.random();
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.x = cx + (Math.random() - 0.5) * 20;
        this.y = cy + (Math.random() - 0.5) * 20;
        this.px = this.x;
        this.py = this.y;
    };
    Star.prototype.update = function(dt) {
        this.twinkleVal += this.twinkleSpeed * dt;
        if (this.isExploding) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.vx *= Math.pow(0.95, dt);
            this.vy *= Math.pow(0.95, dt);
            this.alpha *= Math.pow(0.94, dt);
            return;
        }
        if (suctionMode) {
            var dx = cx - this.x, dy = cy - this.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var pullFactor = ((suctionStrength * 50) / (dist + 10) + (suctionStrength * 0.05)) * dt;
            this.x += dx * pullFactor - (dy * 0.04 * dt);
            this.y += dy * pullFactor + (dx * 0.04 * dt);
            if (dist < 10) {
                var a2 = Math.random() * TAU, r = Math.max(width, height) * 0.8;
                this.x = cx + Math.cos(a2) * r;
                this.y = cy + Math.sin(a2) * r;
                this.z = Math.random() * width;
            }
            var k = 128.0 / (this.z > 0 ? this.z : 1);
            this.px = (this.x - cx) * k + cx;
            this.py = (this.y - cy) * k + cy;
        } else {
            this.z -= warpFactor * dt;
            if (this.z <= 1 || this.z > width * 1.5) {
                this.z = (this.z <= 1) ? width : 2;
                this.x = Math.random() * width;
                this.y = Math.random() * height;
            }
            var wobbleX = 0, wobbleY = 0;
            if (isHolding && !sequenceActive) {
                var wobbleAmount = Math.min((performance.now() - holdStart) / 1000, 1) * 2;
                this.wobblePhase += 0.2 * dt;
                wobbleX = Math.sin(this.wobblePhase) * wobbleAmount;
                wobbleY = Math.cos(this.wobblePhase) * wobbleAmount;
            }
            var k2 = 128.0 / (this.z > 0 ? this.z : 1);
            this.px = ((this.x - cx) * k2 + cx) + wobbleX;
            this.py = ((this.y - cy) * k2 + cy) + wobbleY;
        }
    };

    for (var i = 0; i < STARS_COUNT; i++) stars.push(new Star());

    function createLightningBolt(x, y, radius, segments) {
        var path = [{ x: x, y: y }];
        var angle = Math.random() * TAU;
        var tx = x + Math.cos(angle) * radius;
        var ty = y + Math.sin(angle) * radius;
        var dist = Math.sqrt((tx - x) * (tx - x) + (ty - y) * (ty - y));
        for (var i = 0; i < segments; i++) {
            var progress = (i + 1) / segments;
            path.push({
                x: x + (tx - x) * progress + (Math.random() - 0.5) * (dist * 0.25),
                y: y + (ty - y) * progress + (Math.random() - 0.5) * (dist * 0.25)
            });
        }
        path.push({ x: tx, y: ty });
        lightning.push({ path: path, life: 1 });
    }

    var lastTime = 0;
    function animate(time) {
        var dt = lastTime ? (time - lastTime) / 16.666 : 1;
        lastTime = time;
        ctx.clearRect(0, 0, width, height);
        if (!manualPhysics) warpFactor += (targetWarpFactor - warpFactor) * 0.08 * dt;

        if ((isHolding || sequenceActive) && !systemOnline) {
            var intensity = Math.min(100, Math.max(0, (warpFactor / 30) * 100));
            var fluctuateSpeed = 0.002 + (intensity * 0.0005);
            var mix = (Math.sin(time * fluctuateSpeed) + 1) / 2;
            layerHolo.style.setProperty('--holographic-intensity', intensity + (suctionMode ? Math.random() * 20 : 0));
            if (logoBtn.classList.contains('calibrating') || logoBtn.classList.contains('vacuum-state')) {
                layerHolo.style.opacity = mix;
                layerCyber.style.opacity = 1 - mix;
            }
        } else {
            layerHolo.style.opacity = '';
            layerCyber.style.opacity = '';
        }

        if (gravityActive && suctionMode) {
            suctionStrength *= Math.pow(1.06, dt);
            if (suctionStrength > 2) canvas.style.transform = 'translate(' + (Math.random()*4-2) + 'px, ' + (Math.random()*4-2) + 'px)';
        }

        if (!systemOnline) {
            var wave = Math.sin(time * 0.0015);
            var speedMult = isHolding ? 15 : (sequenceActive ? 40 : 1);
            ringRotation[0] += (0.2 + wave * 0.05) * speedMult * dt;
            ringRotation[1] -= (0.3 + wave * 0.02) * speedMult * dt;
            ringRotation[2] += (0.5 - wave * 0.04) * speedMult * dt;
            ringRotation[3] -= (0.1 + wave * 0.06) * speedMult * dt;
            for (var ri = 0; ri < 4; ri++) rings[ri].style.transform = 'rotate(' + ringRotation[ri] + 'deg)';
        }

        if (isHolding || sequenceActive) {
            var shake = isHolding ? Math.random() * 2 : 0;
            var gX = cx + shake, gY = cy + shake;
            var gradient = ctx.createRadialGradient(gX, gY, 10, gX, gY, 400);
            gradient.addColorStop(0, suctionMode ? 'rgba(255, 255, 255, 0.4)' : 'rgba(0, 255, 255, 0.2)');
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(gX - 400, gY - 400, 800, 800);
        }

        ctx.globalCompositeOperation = 'lighter';
        for (var si = 0; si < STARS_COUNT; si++) {
            var s = stars[si];
            if (systemOnline && !s.isExploding) continue;
            s.update(dt);
            if (s.alpha <= 0.01 || s.px < -50 || s.px > width + 50 || s.py < -50 || s.py > height + 50) continue;
            var twinkleAlpha = 0.7 + 0.3 * Math.sin(s.twinkleVal);
            ctx.globalAlpha = s.alpha * twinkleAlpha;
            ctx.fillStyle = 'rgb(' + s.color + ')';
            if (s.isExploding) {
                var spd = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(Math.atan2(s.vy, s.vx));
                ctx.beginPath();
                ctx.ellipse(0, 0, Math.min(spd * 3, 50), 1, 0, 0, TAU);
                ctx.fill();
                ctx.restore();
            } else if (suctionMode) {
                var sdx = cx - s.px, sdy = cy - s.py;
                var sdist = Math.sqrt(sdx * sdx + sdy * sdy);
                var proximity = 1000 / (sdist + 10);
                var stretch = Math.min(sdist, suctionStrength * 50 * proximity);
                var sangle = Math.atan2(sdy, sdx);
                ctx.strokeStyle = 'rgba(' + s.color + ', ' + Math.min(0.9, proximity/50) + ')';
                ctx.lineWidth = Math.min(s.size, 2);
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(s.px, s.py);
                ctx.quadraticCurveTo(
                    s.px - Math.cos(sangle) * stretch * 0.5 + (sdy * 0.01),
                    s.py - Math.sin(sangle) * stretch * 0.5 - (sdx * 0.01),
                    s.px - Math.cos(sangle) * stretch,
                    s.py - Math.sin(sangle) * stretch
                );
                ctx.stroke();
            } else {
                ctx.beginPath();
                if (s.size < 1.5) ctx.rect(s.px, s.py, s.size, s.size);
                else ctx.arc(s.px, s.py, s.size, 0, TAU);
                ctx.fill();
                if (Math.abs(warpFactor) > 5) {
                    ctx.beginPath();
                    ctx.moveTo(s.px, s.py);
                    var k3 = 128.0 / Math.max(1, s.z + (warpFactor * 2));
                    ctx.lineTo((s.x - cx) * k3 + cx, (s.y - cy) * k3 + cy);
                    ctx.strokeStyle = 'rgba(' + s.color + ', ' + (s.alpha * 0.4) + ')';
                    ctx.lineWidth = s.size;
                    ctx.stroke();
                }
            }
        }

        for (var di = debris.length - 1; di >= 0; di--) {
            var d = debris[di];
            d.x += d.vx * dt; d.y += d.vy * dt;
            d.vx *= Math.pow(0.93, dt); d.vy *= Math.pow(0.93, dt);
            d.life -= d.decay * dt; d.angle += d.spin * dt;
            if (d.life <= 0) { debris.splice(di, 1); continue; }
            ctx.globalAlpha = d.life;
            ctx.fillStyle = d.color;
            ctx.save();
            ctx.translate(d.x, d.y);
            ctx.rotate(d.angle);
            ctx.beginPath();
            ctx.rect(-1.5, -1.5, 3, 3);
            ctx.fill();
            ctx.restore();
        }

        for (var swi = shockwaves.length - 1; swi >= 0; swi--) {
            var sw = shockwaves[swi];
            sw.size += (sw.maxSize - sw.size) * 0.15 * dt;
            sw.life -= 0.02 * dt;
            if (sw.life <= 0) { shockwaves.splice(swi, 1); continue; }
            var drawRing = function(offset, color) {
                ctx.beginPath();
                ctx.arc(cx, cy, Math.max(0, sw.size + offset), 0, TAU);
                ctx.lineWidth = 40 * sw.life;
                ctx.strokeStyle = 'rgba(' + color + ', ' + (sw.life * 0.8) + ')';
                ctx.stroke();
            };
            drawRing(10, '0, 255, 255');
            drawRing(-10, '255, 0, 0');
            drawRing(0, '255, 255, 255');
        }

        if (lightning.length > 0) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#00ffff";
            ctx.lineWidth = 2;
            for (var li2 = lightning.length - 1; li2 >= 0; li2--) {
                var bolt = lightning[li2];
                bolt.life -= 0.1 * dt;
                if (bolt.life <= 0) { lightning.splice(li2, 1); continue; }
                ctx.globalAlpha = bolt.life;
                ctx.strokeStyle = 'rgba(0, 255, 255, ' + bolt.life + ')';
                ctx.beginPath();
                ctx.moveTo(bolt.path[0].x, bolt.path[0].y);
                for (var bp = 0; bp < bolt.path.length; bp++) ctx.lineTo(bolt.path[bp].x, bolt.path[bp].y);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
        }

        if (isHolding && !sequenceActive && performance.now() - holdStart > 1200) logoBtn.classList.add('primed');
        requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    var lightningInterval;
    function startHold(e) {
        if (e.type === 'keydown' && e.key !== 'Enter' && e.key !== ' ') return;
        if (sequenceActive || systemOnline || isHolding) return;
        isHolding = true;
        holdStart = performance.now();
        logoBtn.classList.add('calibrating');
        targetWarpFactor = 30;
        if (navigator.vibrate) navigator.vibrate(20);
        lightningInterval = setInterval(function() {
            if (!isHolding || sequenceActive) { clearInterval(lightningInterval); return; }
            createLightningBolt(cx, cy, 200, 5);
            if (navigator.vibrate) navigator.vibrate(5);
        }, 100);
    }

    function endHold(e) {
        if (e.type === 'keyup' && e.key !== 'Enter' && e.key !== ' ') return;
        if (!isHolding || sequenceActive || systemOnline) return;
        isHolding = false;
        logoBtn.classList.remove('calibrating');
        clearInterval(lightningInterval);
        targetWarpFactor = 0.5;
        if (performance.now() - holdStart > 1200) triggerSequence();
        else logoBtn.classList.remove('primed');
    }

    ['mousedown', 'touchstart'].forEach(function(ev) {
        logoBtn.addEventListener(ev, startHold, { passive: true });
    });
    ['mouseup', 'touchend'].forEach(function(ev) {
        window.addEventListener(ev, endHold, { passive: true });
    });
    logoBtn.addEventListener('keydown', startHold);
    logoBtn.addEventListener('keyup', endHold);

    function triggerSequence() {
        sequenceActive = true;
        logoBtn.classList.remove('primed');
        logoBtn.classList.add('locked');
        manualPhysics = true;

        var startT = performance.now();
        function decayWarp() {
            if (performance.now() - startT < 300) {
                warpFactor *= 0.85;
                if (Math.abs(warpFactor) < 0.1) warpFactor = 0;
                setTimeout(decayWarp, 16);
            } else {
                afterDecay();
            }
        }
        decayWarp();

        function afterDecay() {
            warpFactor = 0;
            for (var li3 = 0; li3 < 8; li3++) {
                createLightningBolt(cx, cy, 600 * Math.random(), 8);
            }

            setTimeout(function() {
                logoBtn.classList.add('vacuum-state');
                suctionMode = true;
                suctionStrength = 0.1;
                gravityActive = true;

                setTimeout(function() {
                    gravityActive = false;
                    logoBtn.classList.add('imploding');
                    document.querySelectorAll('.tech-ring, .hint').forEach(function(el) { el.style.opacity = '0'; });

                    setTimeout(function() {
                        canvas.style.transform = 'none';
                        flashOverlay.classList.add('active');
                        document.body.classList.add('chromatic-impact');
                        if (navigator.vibrate) navigator.vibrate([50, 50, 50]);

                        suctionMode = false;
                        manualPhysics = false;
                        warpFactor = 5;
                        targetWarpFactor = 0.5;

                        for (var es = 0; es < stars.length; es++) stars[es].explode();

                        for (var di2 = 0; di2 < 180; di2++) {
                            var angle = Math.random() * TAU, speed = Math.random() * 25 + 5;
                            debris.push({
                                x: cx, y: cy,
                                vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                                life: 1.0, decay: Math.random() * 0.02 + 0.01,
                                color: Math.random() > 0.3 ? "rgb(255,255,255)" : "rgb(0,255,255)",
                                angle: Math.random() * TAU, spin: (Math.random() - 0.5) * 0.2
                            });
                        }

                        shockwaves.push({ size: 1, maxSize: Math.max(width, height) * 0.9, life: 1 });
                        uiOverlay.classList.add('faded');
                        logoBtn.style.opacity = '0';
                        systemOnline = true;

                        // Reveal site immediately with the flash
                        revealPageContent();

                        setTimeout(function() {
                            logoBtn.classList.remove('imploding', 'locked', 'vacuum-state');
                            logoBtn.classList.add('online');
                            flashOverlay.classList.remove('active');
                            document.body.classList.remove('chromatic-impact');
                        }, 400);
                    }, 200);
                }, 1100);
            }, 100);
        }
    }

    function revealPageContent() {
        // Hide loader elements
        logoBtn.style.display = 'none';
        canvas.style.display = 'none';
        uiOverlay.style.display = 'none';
        flashOverlay.style.display = 'none';

        // Remove pre-boot, restore scroll
        document.body.classList.remove('pre-boot');
        document.body.style.overflow = '';
        document.body.classList.add('site-revealed');

        // Start audio
        var a = document.getElementById('bgMusic');
        if (a) { a.volume = 0.2; a.play().catch(function(){}); }

        // Update audio toggle icons
        var off = document.getElementById('audioIconOff');
        var on = document.getElementById('audioIconOn');
        var b = document.getElementById('audioToggle');
        if (off) off.style.display = 'none';
        if (on) on.style.display = 'block';
        if (b) b.classList.add('audio-active');

        // Reveal hero elements
        var heroLogo = document.querySelector('.hero-logo');
        var heroHeader2 = document.querySelector('.hero-header');
        var lightningCanvas = document.querySelector('.lightning-overlay');
        if (heroLogo) heroLogo.classList.add('token-visible');
        if (heroHeader2) heroHeader2.classList.add('token-visible');
        if (lightningCanvas) lightningCanvas.classList.add('token-visible');

        var tokenGlow = document.getElementById('tokenGlowOverlay');
        if (tokenGlow) tokenGlow.classList.add('token-visible');

        // Brand slam - delayed for impact
        setTimeout(function() {
            var brand = document.getElementById('heroBrand');
            if (brand) brand.classList.add('brand-visible');
            setTimeout(function() {
                var scroll = document.getElementById('scrollIndicator');
                if (scroll) scroll.classList.add('scroll-visible');
            }, 1400);
        }, 1600);
    }
})();

// Global scroll-active flag — canvases pause during scroll to free GPU for compositing
var _isScrolling = false;
var _scrollTimer = null;
window.addEventListener('scroll', function() {
    _isScrolling = true;
    clearTimeout(_scrollTimer);
    _scrollTimer = setTimeout(function() { _isScrolling = false; }, 150);
}, { passive: true });

// Shared debounce for resize handlers
var _resizeCallbacks = [];
var _resizeTimer = null;
window.addEventListener('resize', function() {
    if (_resizeTimer) clearTimeout(_resizeTimer);
    _resizeTimer = setTimeout(function() {
        _resizeCallbacks.forEach(function(fn) { fn(); });
    }, 150);
});
function onResizeDebounced(fn) { _resizeCallbacks.push(fn); }

// Universal section visibility - adds/removes .perf-visible class
// Powers CSS rule: section:not(.perf-visible) * { animation-play-state: paused }
(function() {
    var perfObs = new IntersectionObserver(function(entries) {
        entries.forEach(function(e) {
            if (e.isIntersecting) e.target.classList.add('perf-visible');
            else e.target.classList.remove('perf-visible');
        });
    }, { rootMargin: '100px 0px', threshold: 0 });
    document.querySelectorAll('section, header').forEach(function(s) {
        perfObs.observe(s);
    });
})();

// Nav scroll effect (throttled via rAF)
const nav = document.getElementById('nav');
var scrollRafPending = false;
window.addEventListener('scroll', () => {
    if (scrollRafPending) return;
    scrollRafPending = true;
    requestAnimationFrame(() => {
        scrollRafPending = false;
        nav.classList.toggle('scrolled', window.scrollY > 50);
        if (scrollInd && !scrollIndHidden && window.scrollY > 30) {
            scrollIndHidden = true;
            scrollInd.classList.add('hidden');
        }
    });
}, { passive: true });

// Mobile menu
const toggle = document.getElementById('navToggle');
const links = document.getElementById('navLinks');
toggle.addEventListener('click', () => {
    links.classList.toggle('open');
    toggle.classList.toggle('open');
});

// Close mobile menu on link click
links.querySelectorAll('a').forEach(a => {
    a.addEventListener('click', () => {
        links.classList.remove('open');
        toggle.classList.remove('open');
    });
});

// Scroll-triggered animations — observes all [data-anim] elements
const animObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.classList.add('anim-visible');
            // Also add 'visible' for elements that use the old class
            entry.target.classList.add('visible');
            animObserver.unobserve(entry.target);
        }
    });
}, { threshold: 0.08, rootMargin: '0px 0px -40px 0px' });

document.querySelectorAll('[data-anim]').forEach(el => {
    animObserver.observe(el);
});

// Hero — WebGL Sun Shader with Logo Corona
(() => {
  const canvas = document.getElementById('glcanvas');
  const gl = canvas.getContext('webgl');
  if (!gl) return;

  function resize() {
    const d = 1; // DPR 1.0 — fullscreen shader doesn't need retina resolution
    canvas.width = innerWidth * d;
    canvas.height = innerHeight * d;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  resize();
  addEventListener('resize', resize);

  const vert = `
    attribute vec2 pos;
    void main() { gl_Position = vec4(pos, 0.0, 1.0); }
  `;

  const frag = `
    precision highp float;
    uniform vec2 u_res;
    uniform float u_time;
    void main() {
      vec2 FC = gl_FragCoord.xy;
      float t = u_time;
      vec2 r = u_res;
      vec2 p = (FC * 2.0 - r) / r.y;
      vec3 c = vec3(0.0);
      for (float i = 0.0; i < 12.0; i++) {
        float a = i / 1.5 + t * 0.5;
        vec2 q = p;
        q.x = q.x + sin(q.y * 19.0 + t * 2.0 + i) *
              29.0 * smoothstep(0.0, -2.0, q.y);
        float d = length(q - vec2(cos(a), sin(a)) *
                     (0.4 * smoothstep(0.0, 0.5, -q.y)));
        c = c + vec3(0.10, 0.25, 0.45) * (0.05 / d);
      }
      vec3 col = c * c + vec3(0.01, 0.02, 0.04);
      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function compile(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
      throw new Error(gl.getShaderInfoLog(s));
    return s;
  }

  function link(vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.bindAttribLocation(p, 0, 'pos');
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS))
      throw new Error(gl.getProgramInfoLog(p));
    return p;
  }

  try {
    const vs = compile(vert, gl.VERTEX_SHADER);
    const fs = compile(frag, gl.FRAGMENT_SHADER);
    const program = link(vs, fs);
    gl.useProgram(program);

    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    const u_res  = gl.getUniformLocation(program, 'u_res');
    const u_time = gl.getUniformLocation(program, 'u_time');

        const start = performance.now();

    var heroRunning = true;
    var heroLastFrame = 0;
    function draw() {
      if (!heroRunning) return;
      requestAnimationFrame(draw);
      var now = performance.now();
      if (now - heroLastFrame < 33) return; // ~30fps cap
      heroLastFrame = now;
      const t = (now - start) * 0.001;
      gl.uniform2f(u_res, canvas.width, canvas.height);
      gl.uniform1f(u_time, t);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    }
    // Pause WebGL when tab hidden
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) { heroRunning = false; }
      else if (!heroRunning) { heroRunning = true; draw(); }
    });
    var heroObs = new IntersectionObserver(function(entries) {
      entries.forEach(function(e) {
        if (e.isIntersecting) { if (!heroRunning) { heroRunning = true; draw(); } }
        else { heroRunning = false; }
      });
    }, { threshold: 0.05 });
    heroObs.observe(canvas);
    draw();
  } catch (e) {
    console.error('WebGL shader error:', e);
    // Fallback: dark gradient background so hero isn't blank
    canvas.style.background = 'radial-gradient(ellipse at 50% 80%, #0a1628 0%, #060610 100%)';
  }
})();

// Hero in-view observer
var heroHeader = document.getElementById('heroHeader');
if (heroHeader) {
    heroHeader.classList.add('in-view');
    var heroViewObs = new IntersectionObserver(function(entries) {
        entries.forEach(function(e) {
            if (e.isIntersecting) heroHeader.classList.add('in-view');
            else heroHeader.classList.remove('in-view');
        });
    }, { threshold: 0.05 });
    heroViewObs.observe(heroHeader);
}

// --- HERO COVER PARALLAX ---
// As user scrolls, hero shrinks + drifts up, warp zone covers it
(function() {
    var hero = document.getElementById('heroHeader');
    if (!hero) return;
    var ticking = false;
    window.addEventListener('scroll', function() {
        if (!ticking) {
            ticking = true;
            requestAnimationFrame(function() {
                var scroll = window.scrollY;
                var vh = window.innerHeight;
                // Only apply effect while hero would be visible (first 100vh of scroll)
                if (scroll < vh * 1.2) {
                    var progress = scroll / vh; // 0 to ~1
                    var scale = 1 - progress * 0.15; // shrink to 0.85
                    var translateY = scroll * 0.4; // drift up slower than scroll
                    hero.style.transform = 'translate3d(0,' + translateY + 'px,0) scale(' + scale + ')';
                    hero.style.borderRadius = (progress * 14) + 'px';
                    hero.style.visibility = 'visible';
                } else {
                    // Hide hero completely once scrolled past — prevents bleed-through
                    hero.style.visibility = 'hidden';
                }
                ticking = false;
            });
        }
    }, { passive: true });
})();

// Scroll indicator
var scrollInd = document.getElementById('scrollIndicator');
var scrollIndHidden = false;

</script>

<script>
// Lightning effect around token
(function() {
  const canvas = document.getElementById('lightningCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');

  function resize() {
    var w = window.innerWidth;
    var h = window.innerHeight;
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }
  resize();
  onResizeDebounced(resize);

  // Lightning bolt generator
  function drawBolt(x1, y1, x2, y2, depth) {
    if (depth === 0) {
      ctx.lineTo(x2, y2);
      return;
    }
    const midX = (x1 + x2) / 2 + (Math.random() - 0.5) * (depth * 4);
    const midY = (y1 + y2) / 2 + (Math.random() - 0.5) * (depth * 4);
    drawBolt(x1, y1, midX, midY, depth - 1);
    drawBolt(midX, midY, x2, y2, depth - 1);
  }

  const bolts = [];

  function spawnBolt() {
    const cX = canvas.width / 2;
    const cY = canvas.height * 0.50;
    const radius = canvas.height * 0.05; // match token radius

    // Random angle around the token circle
    const angle1 = Math.random() * Math.PI * 2;
    const angle2 = angle1 + (Math.random() - 0.5) * 1.2; // nearby angle

    const x1 = cX + Math.cos(angle1) * radius * (0.7 + Math.random() * 0.5);
    const y1 = cY + Math.sin(angle1) * radius * (0.7 + Math.random() * 0.5);
    const x2 = cX + Math.cos(angle2) * radius * (0.7 + Math.random() * 0.5);
    const y2 = cY + Math.sin(angle2) * radius * (0.7 + Math.random() * 0.5);

    bolts.push({
      x1, y1, x2, y2,
      life: 1.0,
      decay: 0.02 + Math.random() * 0.03,
      width: 0.5 + Math.random() * 1.5
    });
  }

  var _lightningRunning = true;
  var _lightLastFrame = 0;
  function animate() {
    if (!_lightningRunning) return;
    requestAnimationFrame(animate);
    var now = performance.now();
    if (now - _lightLastFrame < 33) return; // ~30fps cap
    _lightLastFrame = now;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Randomly spawn bolts
    if (Math.random() < 0.15) spawnBolt();
    if (Math.random() < 0.05) { spawnBolt(); spawnBolt(); } // occasional burst

    for (let i = bolts.length - 1; i >= 0; i--) {
      const b = bolts[i];
      b.life -= b.decay;
      if (b.life <= 0) { bolts.splice(i, 1); continue; }

      ctx.save();
      ctx.globalAlpha = b.life * 0.8;
      ctx.strokeStyle = 'rgba(180, 230, 255, 0.9)';
      ctx.lineWidth = b.width;
      ctx.shadowColor = 'rgba(0, 180, 255, 0.6)';
      ctx.shadowBlur = 5;
      ctx.beginPath();
      ctx.moveTo(b.x1, b.y1);
      drawBolt(b.x1, b.y1, b.x2, b.y2, 4);
      ctx.stroke();
      ctx.restore();
    }

  }
  animate();

  // Pause when tab is hidden
  document.addEventListener('visibilitychange', function() {
    if (document.hidden) { _lightningRunning = false; }
    else if (!_lightningRunning) { _lightningRunning = true; animate(); }
  });

  // Pause lightning when hero is off-screen
  var _lightObs = new IntersectionObserver(function(entries) {
    entries.forEach(function(e) {
      if (e.isIntersecting) {
        if (!_lightningRunning) { _lightningRunning = true; animate(); }
      } else {
        _lightningRunning = false;
      }
    });
  }, { threshold: 0.01 });
  _lightObs.observe(canvas);
})();
</script>

<!-- Flow section: constellation bg + SVG path drawing -->
<script>
(function() {
    /* ---- Constellation background ---- */
    var cvs = document.getElementById('flowConstellation');
    var section = document.getElementById('journey');
    if (!cvs || !section) return;

    var ctx = cvs.getContext('2d');
    var dots = [];
    var W, H, dpr;

    function sizeCanvas() {
        var rect = section.getBoundingClientRect();
        W = rect.width;
        H = rect.height;
        cvs.width = W;
        cvs.height = H;
        cvs.style.width = W + 'px';
        cvs.style.height = H + 'px';
        ctx.setTransform(1, 0, 0, 1, 0, 0);
    }

    function initDots() {
        dots = [];
        var count = Math.min(20, Math.floor(W * H / 20000));
        for (var i = 0; i < count; i++) {
            dots.push({
                x: Math.random() * W,
                y: Math.random() * H,
                r: 1 + Math.random() * 1.5,
                a: 0.15 + Math.random() * 0.35,
                dx: (Math.random() - 0.5) * 0.15,
                dy: (Math.random() - 0.5) * 0.1,
                color: Math.random() > 0.7 ? 'rgba(245,158,11,' : 'rgba(64,216,255,'
            });
        }
    }

    sizeCanvas();
    initDots();

    var running = false;
    var constLastFrame = 0;
    function draw() {
        if (!running) return;
        requestAnimationFrame(draw);
        var now = performance.now();
        if (now - constLastFrame < 33) return; // ~30fps
        if (typeof _isScrolling !== 'undefined' && _isScrolling) return; // pause during scroll
        constLastFrame = now;

        ctx.clearRect(0, 0, W, H);

        // Draw dots
        for (var i = 0; i < dots.length; i++) {
            var d = dots[i];
            d.x += d.dx;
            d.y += d.dy;
            if (d.x < 0) d.x = W;
            if (d.x > W) d.x = 0;
            if (d.y < 0) d.y = H;
            if (d.y > H) d.y = 0;

            ctx.beginPath();
            ctx.arc(d.x, d.y, d.r, 0, Math.PI * 2);
            ctx.fillStyle = d.color + d.a + ')';
            ctx.fill();
        }

        // Draw connections — batched single path for performance
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = 'rgba(64,216,255,0.08)';
        ctx.beginPath();
        var connDist = 18000;
        for (var j = 0; j < dots.length; j++) {
            for (var k = j + 1; k < dots.length; k++) {
                var dx = dots[j].x - dots[k].x;
                var dy = dots[j].y - dots[k].y;
                var dist = dx * dx + dy * dy;
                if (dist < connDist) {
                    ctx.moveTo(dots[j].x, dots[j].y);
                    ctx.lineTo(dots[k].x, dots[k].y);
                }
            }
        }
        ctx.stroke();
    }

    // Pause constellation when tab hidden
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) { running = false; }
    });
    var obs = new IntersectionObserver(function(entries) {
        entries.forEach(function(e) {
            if (e.isIntersecting) {
                if (!running) { running = true; draw(); }
            } else { running = false; }
        });
    }, { threshold: 0.05 });
    obs.observe(section);

    onResizeDebounced(function() {
        sizeCanvas();
        initDots();
    });

    /* ---- Elbow connectors between cards and pill labels ---- */
    var elbowSvg = document.getElementById('flowElbowSvg');
    var elbowNs = 'http://www.w3.org/2000/svg';

    function getOffsetRelativeTo(el, ancestor) {
        var x = 0, y = 0, w = el.offsetWidth, h = el.offsetHeight;
        var cur = el;
        while (cur && cur !== ancestor) {
            x += cur.offsetLeft;
            y += cur.offsetTop;
            cur = cur.offsetParent;
        }
        return { left: x, top: y, width: w, height: h };
    }

    function drawElbows() {
        if (window.innerWidth < 900) { elbowSvg.innerHTML = ''; return; }

        var sw = section.offsetWidth;
        var sh = section.scrollHeight;
        elbowSvg.setAttribute('viewBox', '0 0 ' + sw + ' ' + sh);
        elbowSvg.style.width = sw + 'px';
        elbowSvg.style.height = sh + 'px';
        elbowSvg.innerHTML = '';

        var cards = [
            document.getElementById('fn1'),
            document.getElementById('fn2'),
            document.getElementById('fn3'),
            document.getElementById('fn4')
        ];
        var pills = [
            document.getElementById('fpl1'),
            document.getElementById('fpl2'),
            document.getElementById('fpl3')
        ];

        var colors = ['rgba(64,216,255,0.3)', 'rgba(64,216,255,0.3)', 'rgba(245,158,11,0.3)'];
        var dotColors = ['rgba(64,216,255,0.6)', 'rgba(64,216,255,0.6)', 'rgba(245,158,11,0.6)'];

        for (var i = 0; i < pills.length; i++) {
            var cardAbove = cards[i];
            var cardBelow = cards[i + 1];
            var pill = pills[i];
            if (!cardAbove || !cardBelow || !pill) continue;

            var caPos = getOffsetRelativeTo(cardAbove, section);
            var cbPos = getOffsetRelativeTo(cardBelow, section);
            var plPos = getOffsetRelativeTo(pill.parentElement, section);

            // Card above: bottom center
            var ax = caPos.left + caPos.width / 2;
            var ay = caPos.top + caPos.height;

            // Pill: center
            var px = plPos.left + plPos.width / 2;
            var py = plPos.top + plPos.height / 2;

            // Card below: top center
            var bx = cbPos.left + cbPos.width / 2;
            var by = cbPos.top;

            // Segment 1: card above bottom -> pill center
            // Go straight down from card, then 90° turn to pill x, then straight down to pill y
            var midY1 = ay + (py - ay) * 0.5;
            var d1 = 'M ' + ax + ' ' + ay
                    + ' L ' + ax + ' ' + midY1
                    + ' L ' + px + ' ' + midY1
                    + ' L ' + px + ' ' + (py - 14);

            // Segment 2: pill center -> card below top
            // Go straight down from pill, then 90° turn to card x, then straight down to card
            var midY2 = (py + 14) + (by - py - 14) * 0.5;
            var d2 = 'M ' + px + ' ' + (py + 14)
                    + ' L ' + px + ' ' + midY2
                    + ' L ' + bx + ' ' + midY2
                    + ' L ' + bx + ' ' + by;

            // Draw path 1
            var p1 = document.createElementNS(elbowNs, 'path');
            p1.setAttribute('d', d1);
            p1.setAttribute('stroke', colors[i]);
            p1.setAttribute('stroke-width', '1.5');
            p1.setAttribute('stroke-dasharray', '6 4');
            p1.setAttribute('stroke-linecap', 'round');
            p1.setAttribute('fill', 'none');
            elbowSvg.appendChild(p1);

            // Draw path 2
            var p2 = document.createElementNS(elbowNs, 'path');
            p2.setAttribute('d', d2);
            p2.setAttribute('stroke', colors[i]);
            p2.setAttribute('stroke-width', '1.5');
            p2.setAttribute('stroke-dasharray', '6 4');
            p2.setAttribute('stroke-linecap', 'round');
            p2.setAttribute('fill', 'none');
            elbowSvg.appendChild(p2);

            // Dots at card endpoints and pill
            var dotPositions = [
                [ax, ay],
                [px, py - 14],
                [px, py + 14],
                [bx, by]
            ];
            for (var d = 0; d < dotPositions.length; d++) {
                var dot = document.createElementNS(elbowNs, 'circle');
                dot.setAttribute('cx', dotPositions[d][0]);
                dot.setAttribute('cy', dotPositions[d][1]);
                dot.setAttribute('r', '3.5');
                dot.setAttribute('fill', dotColors[i]);
                elbowSvg.appendChild(dot);
            }
        }
    }

    setTimeout(drawElbows, 800);
    onResizeDebounced(drawElbows);
    setTimeout(drawElbows, 2500);
})();
</script>


<script>
// Audio toggle only — loader handles starting playback
(function() {
    var btn = document.getElementById('audioToggle');
    var iconOff = document.getElementById('audioIconOff');
    var iconOn = document.getElementById('audioIconOn');
    var audio = document.getElementById('bgMusic');
    var muted = false;

    btn.addEventListener('click', function() {
        // If audio isn't playing yet, start it
        if (audio.paused) {
            audio.volume = 0.13;
            audio.play().then(function() {
                iconOff.style.display = 'none';
                iconOn.style.display = 'block';
                btn.classList.add('audio-active');
            }).catch(function() {});
            return;
        }
        if (!muted) {
            muted = true;
            audio.volume = 0;
            iconOff.style.display = 'block';
            iconOn.style.display = 'none';
            btn.classList.remove('audio-active');
        } else {
            muted = false;
            audio.volume = 0.13;
            iconOff.style.display = 'none';
            iconOn.style.display = 'block';
            btn.classList.add('audio-active');
        }
    });
})();
</script>


<!-- Mobile fix: adjust audio toggle position based on nav scroll state -->
<script>
(function() {
    var nav = document.getElementById('nav');
    var audioToggle = document.getElementById('audioToggle');
    if (!nav || !audioToggle) return;

    // On mobile, audio button follows nav height via CSS class (no scroll layout reads)
    // Nav only has 2 states: default (padding 16px) and scrolled (padding 10px).
    // We sync a class on audioToggle when nav.scrolled changes, CSS handles top position.
    var isMobile = window.matchMedia("(max-width: 768px)");
    function syncAudioPos() {
        if (!isMobile.matches) return;
        audioToggle.classList.toggle("nav-compact", nav.classList.contains("scrolled"));
    }
    var _audioObs = new MutationObserver(syncAudioPos);
    _audioObs.observe(nav, { attributes: true, attributeFilter: ["class"] });
    syncAudioPos();
})();
</script>


<!-- V2 Section Scripts -->
<script>
// --- SCROLL ANIMATIONS (for manifesto + hero) ---
(function() {
    var animEls = document.querySelectorAll('.hero [data-anim], .manifesto [data-anim]');
    if (!animEls.length) return;
    var observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
            if (entry.isIntersecting) {
                var delay = parseInt(entry.target.getAttribute('data-delay') || '0', 10);
                setTimeout(function() { entry.target.classList.add('anim-visible'); }, delay * 120);
                observer.unobserve(entry.target);
            }
        });
    }, { threshold: 0.15 });
    animEls.forEach(function(el) { observer.observe(el); });
})();



// DNA helix is pure CSS

// --- RIVE AI ANIMATION ---
(function() {
    var section = document.getElementById('autonomy-deep');
    var canvas  = document.getElementById('riveAiCanvas');
    if (!section || !canvas) return;

    var riveInstance = null;

    function initRive() {
        if (typeof rive === 'undefined') return;

        riveInstance = new rive.Rive({
            src: 'ai.riv',
            canvas: canvas,
            autoplay: true,
            fit: rive.Fit.Contain,
            alignment: rive.Alignment.Center,
            onLoad: function() {
                riveInstance.resizeDrawingSurfaceToCanvas();
                section.classList.add('rive-revealed');
                playRive(riveInstance);
            },
            onLoadError: function(e) {
                console.log('Rive load error:', e);
            }
        });

        function onResize() {
            if (riveInstance) riveInstance.resizeDrawingSurfaceToCanvas();
        }
        var resizeTimer;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(onResize, 200);
        });
    }

    function playRive(r) {
        var sms = r.stateMachineNames;
        if (sms && sms.length > 0) {
            r.play(sms[0]);
        } else {
            var anims = r.animationNames;
            if (anims && anims.length > 0) r.play(anims[0]);
        }
    }

    var pendingMouseX = 0, pendingMouseY = 0, mouseRafPending = false;
    document.addEventListener('mousemove', function(e) {
        if (!riveInstance) return;
        if (e.target === canvas) return;
        pendingMouseX = e.clientX;
        pendingMouseY = e.clientY;
        if (mouseRafPending) return;
        mouseRafPending = true;
        requestAnimationFrame(function() {
            mouseRafPending = false;
            canvas.dispatchEvent(new MouseEvent('mousemove', {
                clientX: pendingMouseX, clientY: pendingMouseY, bubbles: true, cancelable: true
            }));
        });
    });

    if (document.readyState === 'complete') {
        initRive();
    } else {
        window.addEventListener('load', initRive);
    }
})();

// --- LATTICE SVG (Quantum section) ---
(function() {
    var el = document.getElementById('lattice');
    if (!el) return;
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 300 300');
    svg.style.width = '100%'; svg.style.height = '100%';
    var ns = 'http://www.w3.org/2000/svg';
    var pts = [];
    for (var row = 0; row < 8; row++) {
        for (var col = 0; col < 8; col++) {
            var x = 30 + col * 35 + (row % 2) * 17;
            var y = 20 + row * 35;
            pts.push({ x: x, y: y });
            var c = document.createElementNS(ns, 'circle');
            c.setAttribute('cx', x); c.setAttribute('cy', y); c.setAttribute('r', '2.5');
            c.setAttribute('fill', '#4da8ff');
            c.setAttribute('opacity', '0.6');
            svg.appendChild(c);
        }
    }
    pts.forEach(function(p, i) {
        pts.forEach(function(q, j) {
            if (j <= i) return;
            var d = Math.hypot(p.x - q.x, p.y - q.y);
            if (d < 45) {
                var line = document.createElementNS(ns, 'line');
                line.setAttribute('x1', p.x); line.setAttribute('y1', p.y);
                line.setAttribute('x2', q.x); line.setAttribute('y2', q.y);
                line.setAttribute('stroke', 'rgba(167,139,250,0.12)');
                line.setAttribute('stroke-width', '0.8');
                svg.appendChild(line);
            }
        });
    });
    el.appendChild(svg);
})();

// --- DEVELOPER ACCORDION ---
(function() {
    document.querySelectorAll('.dev-header').forEach(function(btn) {
        btn.addEventListener('click', function() {
            var panel = btn.parentElement;
            var isOpen = panel.classList.contains('dev-panel--open');
            document.querySelectorAll('.dev-panel').forEach(function(p) { p.classList.remove('dev-panel--open'); p.querySelector('.dev-header').setAttribute('aria-expanded', 'false'); });
            if (!isOpen) {
                panel.classList.add('dev-panel--open');
                btn.setAttribute('aria-expanded', 'true');
            }
        });
    });
})();

// --- COMMUNITY MESH GRADIENT CANVAS ---
(function() {
    var canvas = document.getElementById('communityBg');
    if (!canvas) return;
    var ctx = canvas.getContext('2d');
    var w, h, t = 0, running = false;
    function resize() {
        var r = canvas.parentElement.getBoundingClientRect();
        w = canvas.width = r.width;
        h = canvas.height = r.height;
    }
    resize();
    window.addEventListener('resize', resize);

    window._startCommunityCanvas = function() {
        if (!running) { running = true; drawMesh(); }
    };

    function drawMesh() {
        if (!running) return;
        requestAnimationFrame(drawMesh);
        t += 0.004;
        ctx.clearRect(0, 0, w, h);
        var g1 = ctx.createRadialGradient(
            w * 0.2 + Math.sin(t) * w * 0.15, h * 0.3 + Math.cos(t * 0.6) * h * 0.15, 0,
            w * 0.2, h * 0.3, w * 0.6
        );
        g1.addColorStop(0, 'rgba(167,139,250,0.18)');
        g1.addColorStop(1, 'transparent');
        ctx.fillStyle = g1;
        ctx.fillRect(0, 0, w, h);
        var g2 = ctx.createRadialGradient(
            w * 0.8 + Math.cos(t * 0.8) * w * 0.12, h * 0.7 + Math.sin(t) * h * 0.12, 0,
            w * 0.8, h * 0.7, w * 0.5
        );
        g2.addColorStop(0, 'rgba(52,211,153,0.12)');
        g2.addColorStop(1, 'transparent');
        ctx.fillStyle = g2;
        ctx.fillRect(0, 0, w, h);
        var g3 = ctx.createRadialGradient(
            w * 0.5 + Math.sin(t * 1.3) * w * 0.1, h * 0.5, 0,
            w * 0.5, h * 0.5, w * 0.3
        );
        g3.addColorStop(0, 'rgba(244,114,182,0.08)');
        g3.addColorStop(1, 'transparent');
        ctx.fillStyle = g3;
        ctx.fillRect(0, 0, w, h);
    }
})();

// --- HYBRID PANEL SYSTEM (wheel-snap) ---
window.addEventListener('load', function() {
    if (typeof gsap === 'undefined') return;

    var container = document.getElementById('panelContainer');
    if (!container) return;

    var panels = gsap.utils.toArray('#panelContainer [data-panel]');
    var totalPanels = panels.length;
    if (totalPanels === 0) return;

    container.style.height = '100vh';
    container.style.position = 'relative';
    document.body.classList.add('panels-active');

    panels.forEach(function(panel, i) {
        gsap.set(panel, {
            position: 'fixed',
            top: 0, left: 0,
            width: '100%', height: '100vh',
            zIndex: i,
            autoAlpha: 0,
            scale: 0.85
        });
    });

    var currentIndex = -1;
    var isInPanelZone = false;
    var transitioning = false;
    var TRANSITION_MS = 400;

    function getContainerTop() {
        var el = container;
        var top = 0;
        while (el) {
            top += el.offsetTop;
            el = el.offsetParent;
        }
        return top;
    }

    // Activate animations inside a panel
    var activated = {};
    function activatePanel(panel, index) {
        if (activated[index]) return;
        activated[index] = true;
        panel.classList.add('anim-visible');
        var animEls = panel.querySelectorAll('[data-anim]');
        animEls.forEach(function(el) {
            var delay = parseInt(el.getAttribute('data-delay') || '0', 10);
            setTimeout(function() { el.classList.add('anim-visible'); }, delay * 120 + 200);
        });
        if (panel.id === 'community' && window._startCommunityCanvas) {
            window._startCommunityCanvas();
        }
    }

    function showPanel(newIndex) {
        if (newIndex === currentIndex || newIndex < 0 || newIndex >= totalPanels) return;
        transitioning = true;
        if (currentIndex >= 0 && currentIndex < totalPanels) {
            gsap.to(panels[currentIndex], { scale: 0.85, autoAlpha: 0, duration: 0.35, ease: 'power2.inOut' });
        }
        gsap.to(panels[newIndex], { scale: 1, autoAlpha: 1, duration: 0.35, ease: 'power2.inOut',
            onStart: function() { activatePanel(panels[newIndex], newIndex); },
            onComplete: function() { transitioning = false; }
        });
        currentIndex = newIndex;
    }

    function hideAllPanels() {
        if (currentIndex >= 0 && currentIndex < totalPanels) {
            gsap.to(panels[currentIndex], { scale: 0.85, autoAlpha: 0, duration: 0.3, ease: 'power2.inOut' });
        }
        currentIndex = -1;
        isInPanelZone = false;
    }

    function enterPanelZone(fromBottom) {
        isInPanelZone = true;
        if (window._lenis) window._lenis.stop();
        window.scrollTo(0, getContainerTop());
        if (fromBottom) {
            showPanel(totalPanels - 1);
        } else {
            showPanel(0);
        }
    }
    // Expose soft panel entry for warp tunnel (no scroll jump)
    window._showFirstPanel = function() {
        isInPanelZone = true;
        if (window._lenis) window._lenis.stop();
        showPanel(0);
        // Lock scroll position to panel container after a tick
        setTimeout(function() {
            window.scrollTo(0, getContainerTop());
        }, 50);
    };
    window._enterPanelZone = enterPanelZone;

    function exitPanelZone(direction) {
        hideAllPanels();
        if (window._lenis) window._lenis.start();
        if (direction === 'up') {
            // Scroll to the very end of warp zone (just before panel container)
            // The warp engine will detect re-entry and show content
            var wz = document.getElementById('warpZone');
            if (wz) {
                var wzTop = 0, el = wz;
                while (el) { wzTop += el.offsetTop; el = el.offsetParent; }
                // Place scroll at end of warp zone minus a small offset
                window.scrollTo(0, wzTop + wz.offsetHeight - window.innerHeight - 2);
            } else {
                window.scrollTo(0, getContainerTop() - 2);
            }
        } else {
            window.scrollTo(0, getContainerTop() + container.offsetHeight);
        }
    }

    // --- WHEEL HANDLER ---
    var wheelAccum = 0;
    var wheelTimer = null;
    var WHEEL_THRESHOLD = 50;

    window.addEventListener('wheel', function(e) {
        var sy = window.scrollY || window.pageYOffset;
        var containerTop = getContainerTop();
        var containerBottom = containerTop + container.offsetHeight;

        if (!isInPanelZone) {
            if (e.deltaY > 0 && sy >= containerTop - 10 && sy < containerBottom) {
                e.preventDefault();
                enterPanelZone(false);
                wheelAccum = 0;
                return;
            }
            return;
        }

        e.preventDefault();
        if (transitioning) return;

        wheelAccum += e.deltaY;
        if (wheelTimer) clearTimeout(wheelTimer);
        wheelTimer = setTimeout(function() { wheelAccum = 0; }, 200);

        if (Math.abs(wheelAccum) < WHEEL_THRESHOLD) return;
        var direction = wheelAccum > 0 ? 1 : -1;
        wheelAccum = 0;

        var nextIndex = currentIndex + direction;
        if (nextIndex < 0) {
            exitPanelZone('up');
        } else if (nextIndex >= totalPanels) {
            exitPanelZone('down');
        } else {
            showPanel(nextIndex);
        }
    }, { passive: false });

    // --- TOUCH HANDLER ---
    var touchStartY = 0;
    var touchMoved = false;

    window.addEventListener('touchstart', function(e) {
        touchStartY = e.touches[0].clientY;
        touchMoved = false;
    }, { passive: true });

    window.addEventListener('touchmove', function(e) {
        if (!isInPanelZone) {
            var sy = window.scrollY || window.pageYOffset;
            var containerTop = getContainerTop();
            var deltaY = touchStartY - e.touches[0].clientY;
            if (deltaY > 30 && sy >= containerTop - 10) {
                enterPanelZone(false);
                touchMoved = true;
                e.preventDefault();
                return;
            }
            return;
        }

        e.preventDefault();
        if (transitioning || touchMoved) return;

        var deltaY = touchStartY - e.touches[0].clientY;
        if (Math.abs(deltaY) < 40) return;

        touchMoved = true;
        var direction = deltaY > 0 ? 1 : -1;
        var nextIndex = currentIndex + direction;

        if (nextIndex < 0) {
            exitPanelZone('up');
        } else if (nextIndex >= totalPanels) {
            exitPanelZone('down');
        } else {
            showPanel(nextIndex);
        }
    }, { passive: false });

    // --- SCROLL WATCHER ---
    window.addEventListener('scroll', function() {
        var sy = window.scrollY || window.pageYOffset;
        var containerTop = getContainerTop();
        if (isInPanelZone) {
            if (Math.abs(sy - containerTop) > 50) {
                window.scrollTo(0, containerTop);
            }
        }
    }, { passive: true });

    // --- NAV LINK CLICKS ---
    document.querySelectorAll('a[href^="#"]').forEach(function(link) {
        link.addEventListener('click', function(e) {
            var targetId = link.getAttribute('href').substring(1);
            if (!targetId) return;

            var normalTarget = document.getElementById(targetId);
            if (normalTarget && !normalTarget.hasAttribute('data-panel')) {
                e.preventDefault();
                if (isInPanelZone) hideAllPanels();
                normalTarget.scrollIntoView({ behavior: 'smooth' });
                return;
            }

            var targetPanel = container.querySelector('[data-panel]#' + targetId);
            if (!targetPanel) return;
            var panelIndex = panels.indexOf(targetPanel);
            if (panelIndex === -1) return;
            e.preventDefault();
            if (!isInPanelZone) {
                window.scrollTo(0, getContainerTop());
                isInPanelZone = true;
            }
            showPanel(panelIndex);
        });
    });
});
</script>

</body>
</html>
